{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _typeof = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.match.js\");\n\nrequire(\"core-js/modules/es.number.parse-int.js\");\n\nrequire(\"core-js/modules/es.number.constructor.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.object.freeze.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar _require = require('util'),\n    promisify = _require.promisify;\n\nvar fsevents;\n\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  var mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    var maj = Number.parseInt(mtch[1], 10);\n    var min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nvar _require2 = require('./constants'),\n    EV_ADD = _require2.EV_ADD,\n    EV_CHANGE = _require2.EV_CHANGE,\n    EV_ADD_DIR = _require2.EV_ADD_DIR,\n    EV_UNLINK = _require2.EV_UNLINK,\n    EV_ERROR = _require2.EV_ERROR,\n    STR_DATA = _require2.STR_DATA,\n    STR_END = _require2.STR_END,\n    FSEVENT_CREATED = _require2.FSEVENT_CREATED,\n    FSEVENT_MODIFIED = _require2.FSEVENT_MODIFIED,\n    FSEVENT_DELETED = _require2.FSEVENT_DELETED,\n    FSEVENT_MOVED = _require2.FSEVENT_MOVED,\n    FSEVENT_UNKNOWN = _require2.FSEVENT_UNKNOWN,\n    FSEVENT_TYPE_FILE = _require2.FSEVENT_TYPE_FILE,\n    FSEVENT_TYPE_DIRECTORY = _require2.FSEVENT_TYPE_DIRECTORY,\n    FSEVENT_TYPE_SYMLINK = _require2.FSEVENT_TYPE_SYMLINK,\n    ROOT_GLOBSTAR = _require2.ROOT_GLOBSTAR,\n    DIR_SUFFIX = _require2.DIR_SUFFIX,\n    DOT_SLASH = _require2.DOT_SLASH,\n    FUNCTION_TYPE = _require2.FUNCTION_TYPE,\n    EMPTY_FN = _require2.EMPTY_FN,\n    IDENTITY_FN = _require2.IDENTITY_FN;\n\nvar Depth = function Depth(value) {\n  return isNaN(value) ? {} : {\n    depth: value\n  };\n};\n\nvar stat = promisify(fs.stat);\nvar lstat = promisify(fs.lstat);\nvar realpath = promisify(fs.realpath);\nvar statMethods = {\n  stat: stat,\n  lstat: lstat\n};\n/**\r\n * @typedef {String} Path\r\n */\n\n/**\r\n * @typedef {Object} FsEventsWatchContainer\r\n * @property {Set<Function>} listeners\r\n * @property {Function} rawEmitter\r\n * @property {{stop: Function}} watcher\r\n */\n// fsevents instance helper functions\n\n/**\r\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\r\n * @type {Map<Path,FsEventsWatchContainer>}\r\n */\n\nvar FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nvar consolidateThreshhold = 10;\nvar wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\r\n * Instantiates the fsevents interface\r\n * @param {Path} path path to be watched\r\n * @param {Function} callback called when fsevents is bound and ready\r\n * @returns {{stop: Function}} new fsevents instance\r\n */\n\nvar createFSEventsInstance = function createFSEventsInstance(path, callback) {\n  var stop = fsevents.watch(path, callback);\n  return {\n    stop: stop\n  };\n};\n/**\r\n * Instantiates the fsevents interface or binds listeners to an existing one covering\r\n * the same file tree.\r\n * @param {Path} path           - to be watched\r\n * @param {Path} realPath       - real path for symlinks\r\n * @param {Function} listener   - called when fsevents emits events\r\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\r\n * @returns {Function} closer\r\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n  var parentPath = sysPath.dirname(watchPath);\n  var cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n\n  var filteredListener = function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  var watchedParent = false;\n\n  var _iterator = _createForOfIteratorHelper(FSEventsWatchers.keys()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var watchedPath = _step.value;\n\n      if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n        watchPath = watchedPath;\n        cont = FSEventsWatchers.get(watchPath);\n        watchedParent = true;\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter: rawEmitter,\n      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {\n        if (!cont.listeners.size) return;\n        var info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(function (list) {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return function () {\n    var lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(function () {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nvar couldConsolidate = function couldConsolidate(path) {\n  var count = 0;\n\n  var _iterator2 = _createForOfIteratorHelper(FSEventsWatchers.keys()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var watchPath = _step2.value;\n\n      if (watchPath.indexOf(path) === 0) {\n        count++;\n\n        if (count >= consolidateThreshhold) {\n          return true;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nvar canUse = function canUse() {\n  return fsevents && FSEventsWatchers.size < 128;\n}; // determines subdirectory traversal levels from root to path\n\n\nvar calcDepth = function calcDepth(path, root) {\n  var i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) {\n    i++;\n  }\n\n  return i;\n}; // returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\n\n\nvar sameTypes = function sameTypes(info, stats) {\n  return info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n};\n/**\r\n * @mixin\r\n */\n\n\nvar FsEventsHandler = /*#__PURE__*/function () {\n  /**\r\n   * @param {import('../index').FSWatcher} fsw\r\n   */\n  function FsEventsHandler(fsw) {\n    _classCallCheck(this, FsEventsHandler);\n\n    this.fsw = fsw;\n  }\n\n  _createClass(FsEventsHandler, [{\n    key: \"checkIgnored\",\n    value: function checkIgnored(path, stats) {\n      var ipaths = this.fsw._ignoredPaths;\n\n      if (this.fsw._isIgnored(path, stats)) {\n        ipaths.add(path);\n\n        if (stats && stats.isDirectory()) {\n          ipaths.add(path + ROOT_GLOBSTAR);\n        }\n\n        return true;\n      }\n\n      ipaths.delete(path);\n      ipaths.delete(path + ROOT_GLOBSTAR);\n    }\n  }, {\n    key: \"addOrChange\",\n    value: function addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n      var event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n      this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }, {\n    key: \"checkExists\",\n    value: function () {\n      var _checkExists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n        var stats;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return stat(path);\n\n              case 3:\n                stats = _context.sent;\n\n                if (!this.fsw.closed) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 6:\n                if (sameTypes(info, stats)) {\n                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                } else {\n                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                }\n\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (_context.t0.code === 'EACCES') {\n                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                } else {\n                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                }\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 9]]);\n      }));\n\n      function checkExists(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n        return _checkExists.apply(this, arguments);\n      }\n\n      return checkExists;\n    }()\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n      if (this.fsw.closed || this.checkIgnored(path)) return;\n\n      if (event === EV_UNLINK) {\n        var isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files\n\n        if (isDirectory || watchedDir.has(item)) {\n          this.fsw._remove(parent, item, isDirectory);\n        }\n      } else {\n        if (event === EV_ADD) {\n          // track new directories\n          if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n          if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } // track new paths\n          // (other than symlinks being followed, which will be tracked soon)\n\n\n          this.fsw._getWatchedDir(parent).add(item);\n        }\n        /**\r\n         * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\r\n         */\n\n\n        var eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n        this.fsw._emit(eventName, path);\n\n        if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n      }\n    }\n    /**\r\n     * Handle symlinks encountered during directory scan\r\n     * @param {String} watchPath  - file/dir path to be watched with fsevents\r\n     * @param {String} realPath   - real path (in case of symlinks)\r\n     * @param {Function} transform  - path transformer\r\n     * @param {Function} globFilter - path filter in case a glob pattern was provided\r\n     * @returns {Function} closer for the watcher instance\r\n    */\n\n  }, {\n    key: \"_watchWithFsEvents\",\n    value: function _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n      var _this = this;\n\n      if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n      var opts = this.fsw.options;\n\n      var watchCallback = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(fullPath, flags, info) {\n          var path, parent, item, watchedDir, stats;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!_this.fsw.closed) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 2:\n                  if (!(opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth)) {\n                    _context2.next = 4;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 4:\n                  path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n\n                  if (!(globFilter && !globFilter(path))) {\n                    _context2.next = 7;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 7:\n                  // ensure directories are tracked\n                  parent = sysPath.dirname(path);\n                  item = sysPath.basename(path);\n                  watchedDir = _this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n                  if (!(wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN)) {\n                    _context2.next = 30;\n                    break;\n                  }\n\n                  if (!(_typeof(opts.ignored) === FUNCTION_TYPE)) {\n                    _context2.next = 27;\n                    break;\n                  }\n\n                  _context2.prev = 12;\n                  _context2.next = 15;\n                  return stat(path);\n\n                case 15:\n                  stats = _context2.sent;\n                  _context2.next = 20;\n                  break;\n\n                case 18:\n                  _context2.prev = 18;\n                  _context2.t0 = _context2[\"catch\"](12);\n\n                case 20:\n                  if (!_this.fsw.closed) {\n                    _context2.next = 22;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 22:\n                  if (!_this.checkIgnored(path, stats)) {\n                    _context2.next = 24;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 24:\n                  if (sameTypes(info, stats)) {\n                    _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                  } else {\n                    _this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n                  }\n\n                  _context2.next = 28;\n                  break;\n\n                case 27:\n                  _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n                case 28:\n                  _context2.next = 35;\n                  break;\n\n                case 30:\n                  _context2.t1 = info.event;\n                  _context2.next = _context2.t1 === FSEVENT_CREATED ? 33 : _context2.t1 === FSEVENT_MODIFIED ? 33 : _context2.t1 === FSEVENT_DELETED ? 34 : _context2.t1 === FSEVENT_MOVED ? 34 : 35;\n                  break;\n\n                case 33:\n                  return _context2.abrupt(\"return\", _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts));\n\n                case 34:\n                  return _context2.abrupt(\"return\", _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts));\n\n                case 35:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[12, 18]]);\n        }));\n\n        return function watchCallback(_x9, _x10, _x11) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n\n      this.fsw._emitReady();\n\n      return closer;\n    }\n    /**\r\n     * Handle symlinks encountered during directory scan\r\n     * @param {String} linkPath path to symlink\r\n     * @param {String} fullPath absolute path to the symlink\r\n     * @param {Function} transform pre-existing path transformer\r\n     * @param {Number} curDepth level of subdirectories traversed to where symlink is\r\n     * @returns {Promise<void>}\r\n     */\n\n  }, {\n    key: \"_handleFsEventsSymlink\",\n    value: function () {\n      var _handleFsEventsSymlink2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(linkPath, fullPath, transform, curDepth) {\n        var linkTarget;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                this.fsw._symlinkPaths.set(fullPath, true);\n\n                this.fsw._incrReadyCount();\n\n                _context3.prev = 4;\n                _context3.next = 7;\n                return realpath(linkPath);\n\n              case 7:\n                linkTarget = _context3.sent;\n\n                if (!this.fsw.closed) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 10:\n                if (!this.fsw._isIgnored(linkTarget)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.fsw._emitReady());\n\n              case 12:\n                this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n                // that causes emitted paths to incorporate the link's path\n\n\n                this._addToFsEvents(linkTarget || linkPath, function (path) {\n                  var aliasedPath = linkPath;\n\n                  if (linkTarget && linkTarget !== DOT_SLASH) {\n                    aliasedPath = path.replace(linkTarget, linkPath);\n                  } else if (path !== DOT_SLASH) {\n                    aliasedPath = sysPath.join(linkPath, path);\n                  }\n\n                  return transform(aliasedPath);\n                }, false, curDepth);\n\n                _context3.next = 20;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](4);\n\n                if (!this.fsw._handleError(_context3.t0)) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.fsw._emitReady());\n\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[4, 16]]);\n      }));\n\n      function _handleFsEventsSymlink(_x12, _x13, _x14, _x15) {\n        return _handleFsEventsSymlink2.apply(this, arguments);\n      }\n\n      return _handleFsEventsSymlink;\n    }()\n    /**\r\n     *\r\n     * @param {Path} newPath\r\n     * @param {fs.Stats} stats\r\n     */\n\n  }, {\n    key: \"emitAdd\",\n    value: function emitAdd(newPath, stats, processPath, opts, forceAdd) {\n      var pp = processPath(newPath);\n      var isDir = stats.isDirectory();\n\n      var dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n\n      var base = sysPath.basename(pp); // ensure empty dirs get tracked\n\n      if (isDir) this.fsw._getWatchedDir(pp);\n      if (dirObj.has(base)) return;\n      dirObj.add(base);\n\n      if (!opts.ignoreInitial || forceAdd === true) {\n        this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n      }\n    }\n  }, {\n    key: \"initWatch\",\n    value: function initWatch(realPath, path, wh, processPath) {\n      if (this.fsw.closed) return;\n\n      var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n      this.fsw._addPathCloser(path, closer);\n    }\n    /**\r\n     * Handle added path with fsevents\r\n     * @param {String} path file/dir path or glob pattern\r\n     * @param {Function|Boolean=} transform converts working path to what the user expects\r\n     * @param {Boolean=} forceAdd ensure add is emitted\r\n     * @param {Number=} priorDepth Level of subdirectories already traversed.\r\n     * @returns {Promise<void>}\r\n     */\n\n  }, {\n    key: \"_addToFsEvents\",\n    value: function () {\n      var _addToFsEvents2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(path, transform, forceAdd, priorDepth) {\n        var _this2 = this;\n\n        var opts, processPath, wh, stats, realPath;\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.fsw.closed) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                opts = this.fsw.options;\n                processPath = _typeof(transform) === FUNCTION_TYPE ? transform : IDENTITY_FN;\n                wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n                _context4.prev = 5;\n                _context4.next = 8;\n                return statMethods[wh.statMethod](wh.watchPath);\n\n              case 8:\n                stats = _context4.sent;\n\n                if (!this.fsw.closed) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 11:\n                if (!this.fsw._isIgnored(wh.watchPath, stats)) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                throw null;\n\n              case 13:\n                if (!stats.isDirectory()) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                // emit addDir unless this is a glob parent\n                if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n                if (!(priorDepth && priorDepth > opts.depth)) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 17:\n                // scan the contents of the dir\n                this.fsw._readdirp(wh.watchPath, _objectSpread({\n                  fileFilter: function fileFilter(entry) {\n                    return wh.filterPath(entry);\n                  },\n                  directoryFilter: function directoryFilter(entry) {\n                    return wh.filterDir(entry);\n                  }\n                }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, function (entry) {\n                  // need to check filterPath on dirs b/c filterDir is less restrictive\n                  if (_this2.fsw.closed) {\n                    return;\n                  }\n\n                  if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n                  var joinedPath = sysPath.join(wh.watchPath, entry.path);\n                  var fullPath = entry.fullPath;\n\n                  if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n                    // preserve the current depth here since it can't be derived from\n                    // real paths past the symlink\n                    var curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n                    _this2._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n                  } else {\n                    _this2.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n                  }\n                }).on(EV_ERROR, EMPTY_FN).on(STR_END, function () {\n                  _this2.fsw._emitReady();\n                });\n\n                _context4.next = 22;\n                break;\n\n              case 20:\n                this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n                this.fsw._emitReady();\n\n              case 22:\n                _context4.next = 27;\n                break;\n\n              case 24:\n                _context4.prev = 24;\n                _context4.t0 = _context4[\"catch\"](5);\n\n                if (!_context4.t0 || this.fsw._handleError(_context4.t0)) {\n                  // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n                  this.fsw._emitReady();\n\n                  this.fsw._emitReady();\n                }\n\n              case 27:\n                if (!(opts.persistent && forceAdd !== true)) {\n                  _context4.next = 41;\n                  break;\n                }\n\n                if (!(_typeof(transform) === FUNCTION_TYPE)) {\n                  _context4.next = 32;\n                  break;\n                }\n\n                // realpath has already been resolved\n                this.initWatch(undefined, path, wh, processPath);\n                _context4.next = 41;\n                break;\n\n              case 32:\n                _context4.prev = 32;\n                _context4.next = 35;\n                return realpath(wh.watchPath);\n\n              case 35:\n                realPath = _context4.sent;\n                _context4.next = 40;\n                break;\n\n              case 38:\n                _context4.prev = 38;\n                _context4.t1 = _context4[\"catch\"](32);\n\n              case 40:\n                this.initWatch(realPath, path, wh, processPath);\n\n              case 41:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[5, 24], [32, 38]]);\n      }));\n\n      function _addToFsEvents(_x16, _x17, _x18, _x19) {\n        return _addToFsEvents2.apply(this, arguments);\n      }\n\n      return _addToFsEvents;\n    }()\n  }]);\n\n  return FsEventsHandler;\n}();\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":{"version":3,"sources":["C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/chokidar/lib/fsevents-handler.js"],"names":["fs","require","sysPath","promisify","fsevents","error","process","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","match","maj","Number","parseInt","min","undefined","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_ERROR","STR_DATA","STR_END","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","ROOT_GLOBSTAR","DIR_SUFFIX","DOT_SLASH","FUNCTION_TYPE","EMPTY_FN","IDENTITY_FN","Depth","value","isNaN","depth","stat","lstat","realpath","statMethods","FSEventsWatchers","Map","consolidateThreshhold","wrongEventFlags","Set","createFSEventsInstance","path","callback","stop","watch","setFSEventsListener","realPath","listener","rawEmitter","watchPath","extname","dirname","parentPath","cont","get","couldConsolidate","resolvedPath","resolve","hasSymlink","filteredListener","fullPath","flags","info","replace","indexOf","sep","watchedParent","keys","watchedPath","listeners","add","watcher","size","getInfo","forEach","list","event","set","lst","delete","then","Object","freeze","count","canUse","calcDepth","root","i","sameTypes","stats","type","isDirectory","isSymbolicLink","isFile","FsEventsHandler","fsw","ipaths","_ignoredPaths","_isIgnored","parent","watchedDir","item","opts","has","handleEvent","closed","addOrChange","code","checkIgnored","_remove","_getWatchedDir","followSymlinks","curDepth","_addToFsEvents","eventName","_emit","transform","globFilter","options","watchCallback","join","relative","basename","ignored","checkExists","closer","_emitRaw","_emitReady","linkPath","_symlinkPaths","_incrReadyCount","linkTarget","aliasedPath","_handleError","newPath","processPath","forceAdd","pp","isDir","dirObj","base","ignoreInitial","wh","_watchWithFsEvents","_addPathCloser","priorDepth","_getWatchHelpers","statMethod","emitAdd","_readdirp","fileFilter","entry","filterPath","directoryFilter","filterDir","on","joinedPath","_handleFsEventsSymlink","persistent","initWatch","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst sysPath = require('path');\r\nconst { promisify } = require('util');\r\n\r\nlet fsevents;\r\ntry {\r\n  fsevents = require('fsevents');\r\n} catch (error) {\r\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\r\n}\r\n\r\nif (fsevents) {\r\n  // TODO: real check\r\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\r\n  if (mtch && mtch[1] && mtch[2]) {\r\n    const maj = Number.parseInt(mtch[1], 10);\r\n    const min = Number.parseInt(mtch[2], 10);\r\n    if (maj === 8 && min < 16) {\r\n      fsevents = undefined;\r\n    }\r\n  }\r\n}\r\n\r\nconst {\r\n  EV_ADD,\r\n  EV_CHANGE,\r\n  EV_ADD_DIR,\r\n  EV_UNLINK,\r\n  EV_ERROR,\r\n  STR_DATA,\r\n  STR_END,\r\n  FSEVENT_CREATED,\r\n  FSEVENT_MODIFIED,\r\n  FSEVENT_DELETED,\r\n  FSEVENT_MOVED,\r\n  // FSEVENT_CLONED,\r\n  FSEVENT_UNKNOWN,\r\n  FSEVENT_TYPE_FILE,\r\n  FSEVENT_TYPE_DIRECTORY,\r\n  FSEVENT_TYPE_SYMLINK,\r\n\r\n  ROOT_GLOBSTAR,\r\n  DIR_SUFFIX,\r\n  DOT_SLASH,\r\n  FUNCTION_TYPE,\r\n  EMPTY_FN,\r\n  IDENTITY_FN\r\n} = require('./constants');\r\n\r\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\r\n\r\nconst stat = promisify(fs.stat);\r\nconst lstat = promisify(fs.lstat);\r\nconst realpath = promisify(fs.realpath);\r\n\r\nconst statMethods = { stat, lstat };\r\n\r\n/**\r\n * @typedef {String} Path\r\n */\r\n\r\n/**\r\n * @typedef {Object} FsEventsWatchContainer\r\n * @property {Set<Function>} listeners\r\n * @property {Function} rawEmitter\r\n * @property {{stop: Function}} watcher\r\n */\r\n\r\n// fsevents instance helper functions\r\n/**\r\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\r\n * @type {Map<Path,FsEventsWatchContainer>}\r\n */\r\nconst FSEventsWatchers = new Map();\r\n\r\n// Threshold of duplicate path prefixes at which to start\r\n// consolidating going forward\r\nconst consolidateThreshhold = 10;\r\n\r\nconst wrongEventFlags = new Set([\r\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\r\n]);\r\n\r\n/**\r\n * Instantiates the fsevents interface\r\n * @param {Path} path path to be watched\r\n * @param {Function} callback called when fsevents is bound and ready\r\n * @returns {{stop: Function}} new fsevents instance\r\n */\r\nconst createFSEventsInstance = (path, callback) => {\r\n  const stop = fsevents.watch(path, callback);\r\n  return {stop};\r\n};\r\n\r\n/**\r\n * Instantiates the fsevents interface or binds listeners to an existing one covering\r\n * the same file tree.\r\n * @param {Path} path           - to be watched\r\n * @param {Path} realPath       - real path for symlinks\r\n * @param {Function} listener   - called when fsevents emits events\r\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\r\n * @returns {Function} closer\r\n */\r\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\r\n  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\r\n\r\n  const parentPath = sysPath.dirname(watchPath);\r\n  let cont = FSEventsWatchers.get(watchPath);\r\n\r\n  // If we've accumulated a substantial number of paths that\r\n  // could have been consolidated by watching one directory\r\n  // above the current one, create a watcher on the parent\r\n  // path instead, so that we do consolidate going forward.\r\n  if (couldConsolidate(parentPath)) {\r\n    watchPath = parentPath;\r\n  }\r\n\r\n  const resolvedPath = sysPath.resolve(path);\r\n  const hasSymlink = resolvedPath !== realPath;\r\n\r\n  const filteredListener = (fullPath, flags, info) => {\r\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\r\n    if (\r\n      fullPath === resolvedPath ||\r\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\r\n    ) listener(fullPath, flags, info);\r\n  };\r\n\r\n  // check if there is already a watcher on a parent path\r\n  // modifies `watchPath` to the parent path when it finds a match\r\n  let watchedParent = false;\r\n  for (const watchedPath of FSEventsWatchers.keys()) {\r\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\r\n      watchPath = watchedPath;\r\n      cont = FSEventsWatchers.get(watchPath);\r\n      watchedParent = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (cont || watchedParent) {\r\n    cont.listeners.add(filteredListener);\r\n  } else {\r\n    cont = {\r\n      listeners: new Set([filteredListener]),\r\n      rawEmitter,\r\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\r\n        if (!cont.listeners.size) return;\r\n        const info = fsevents.getInfo(fullPath, flags);\r\n        cont.listeners.forEach(list => {\r\n          list(fullPath, flags, info);\r\n        });\r\n\r\n        cont.rawEmitter(info.event, fullPath, info);\r\n      })\r\n    };\r\n    FSEventsWatchers.set(watchPath, cont);\r\n  }\r\n\r\n  // removes this instance's listeners and closes the underlying fsevents\r\n  // instance if there are no more listeners left\r\n  return () => {\r\n    const lst = cont.listeners;\r\n\r\n    lst.delete(filteredListener);\r\n    if (!lst.size) {\r\n      FSEventsWatchers.delete(watchPath);\r\n      if (cont.watcher) return cont.watcher.stop().then(() => {\r\n        cont.rawEmitter = cont.watcher = undefined;\r\n        Object.freeze(cont);\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n// Decide whether or not we should start a new higher-level\r\n// parent watcher\r\nconst couldConsolidate = (path) => {\r\n  let count = 0;\r\n  for (const watchPath of FSEventsWatchers.keys()) {\r\n    if (watchPath.indexOf(path) === 0) {\r\n      count++;\r\n      if (count >= consolidateThreshhold) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n// returns boolean indicating whether fsevents can be used\r\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\r\n\r\n// determines subdirectory traversal levels from root to path\r\nconst calcDepth = (path, root) => {\r\n  let i = 0;\r\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\r\n  return i;\r\n};\r\n\r\n// returns boolean indicating whether the fsevents' event info has the same type\r\n// as the one returned by fs.stat\r\nconst sameTypes = (info, stats) => (\r\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\r\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\r\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\r\n)\r\n\r\n/**\r\n * @mixin\r\n */\r\nclass FsEventsHandler {\r\n\r\n/**\r\n * @param {import('../index').FSWatcher} fsw\r\n */\r\nconstructor(fsw) {\r\n  this.fsw = fsw;\r\n}\r\ncheckIgnored(path, stats) {\r\n  const ipaths = this.fsw._ignoredPaths;\r\n  if (this.fsw._isIgnored(path, stats)) {\r\n    ipaths.add(path);\r\n    if (stats && stats.isDirectory()) {\r\n      ipaths.add(path + ROOT_GLOBSTAR);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  ipaths.delete(path);\r\n  ipaths.delete(path + ROOT_GLOBSTAR);\r\n}\r\n\r\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\r\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n}\r\n\r\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  try {\r\n    const stats = await stat(path)\r\n    if (this.fsw.closed) return;\r\n    if (sameTypes(info, stats)) {\r\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    } else {\r\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    }\r\n  } catch (error) {\r\n    if (error.code === 'EACCES') {\r\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    } else {\r\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    }\r\n  }\r\n}\r\n\r\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  if (this.fsw.closed || this.checkIgnored(path)) return;\r\n\r\n  if (event === EV_UNLINK) {\r\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\r\n    // suppress unlink events on never before seen files\r\n    if (isDirectory || watchedDir.has(item)) {\r\n      this.fsw._remove(parent, item, isDirectory);\r\n    }\r\n  } else {\r\n    if (event === EV_ADD) {\r\n      // track new directories\r\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\r\n\r\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\r\n        // push symlinks back to the top of the stack to get handled\r\n        const curDepth = opts.depth === undefined ?\r\n          undefined : calcDepth(fullPath, realPath) + 1;\r\n        return this._addToFsEvents(path, false, true, curDepth);\r\n      }\r\n\r\n      // track new paths\r\n      // (other than symlinks being followed, which will be tracked soon)\r\n      this.fsw._getWatchedDir(parent).add(item);\r\n    }\r\n    /**\r\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\r\n     */\r\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\r\n    this.fsw._emit(eventName, path);\r\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle symlinks encountered during directory scan\r\n * @param {String} watchPath  - file/dir path to be watched with fsevents\r\n * @param {String} realPath   - real path (in case of symlinks)\r\n * @param {Function} transform  - path transformer\r\n * @param {Function} globFilter - path filter in case a glob pattern was provided\r\n * @returns {Function} closer for the watcher instance\r\n*/\r\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\r\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\r\n  const opts = this.fsw.options;\r\n  const watchCallback = async (fullPath, flags, info) => {\r\n    if (this.fsw.closed) return;\r\n    if (\r\n      opts.depth !== undefined &&\r\n      calcDepth(fullPath, realPath) > opts.depth\r\n    ) return;\r\n    const path = transform(sysPath.join(\r\n      watchPath, sysPath.relative(watchPath, fullPath)\r\n    ));\r\n    if (globFilter && !globFilter(path)) return;\r\n    // ensure directories are tracked\r\n    const parent = sysPath.dirname(path);\r\n    const item = sysPath.basename(path);\r\n    const watchedDir = this.fsw._getWatchedDir(\r\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\r\n    );\r\n\r\n    // correct for wrong events emitted\r\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\r\n      if (typeof opts.ignored === FUNCTION_TYPE) {\r\n        let stats;\r\n        try {\r\n          stats = await stat(path);\r\n        } catch (error) {}\r\n        if (this.fsw.closed) return;\r\n        if (this.checkIgnored(path, stats)) return;\r\n        if (sameTypes(info, stats)) {\r\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n        } else {\r\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n        }\r\n      } else {\r\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      }\r\n    } else {\r\n      switch (info.event) {\r\n      case FSEVENT_CREATED:\r\n      case FSEVENT_MODIFIED:\r\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      case FSEVENT_DELETED:\r\n      case FSEVENT_MOVED:\r\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      }\r\n    }\r\n  };\r\n\r\n  const closer = setFSEventsListener(\r\n    watchPath,\r\n    realPath,\r\n    watchCallback,\r\n    this.fsw._emitRaw\r\n  );\r\n\r\n  this.fsw._emitReady();\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Handle symlinks encountered during directory scan\r\n * @param {String} linkPath path to symlink\r\n * @param {String} fullPath absolute path to the symlink\r\n * @param {Function} transform pre-existing path transformer\r\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\r\n * @returns {Promise<void>}\r\n */\r\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\r\n  // don't follow the same symlink more than once\r\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\r\n\r\n  this.fsw._symlinkPaths.set(fullPath, true);\r\n  this.fsw._incrReadyCount();\r\n\r\n  try {\r\n    const linkTarget = await realpath(linkPath);\r\n    if (this.fsw.closed) return;\r\n    if (this.fsw._isIgnored(linkTarget)) {\r\n      return this.fsw._emitReady();\r\n    }\r\n\r\n    this.fsw._incrReadyCount();\r\n\r\n    // add the linkTarget for watching with a wrapper for transform\r\n    // that causes emitted paths to incorporate the link's path\r\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\r\n      let aliasedPath = linkPath;\r\n      if (linkTarget && linkTarget !== DOT_SLASH) {\r\n        aliasedPath = path.replace(linkTarget, linkPath);\r\n      } else if (path !== DOT_SLASH) {\r\n        aliasedPath = sysPath.join(linkPath, path);\r\n      }\r\n      return transform(aliasedPath);\r\n    }, false, curDepth);\r\n  } catch(error) {\r\n    if (this.fsw._handleError(error)) {\r\n      return this.fsw._emitReady();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Path} newPath\r\n * @param {fs.Stats} stats\r\n */\r\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\r\n  const pp = processPath(newPath);\r\n  const isDir = stats.isDirectory();\r\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\r\n  const base = sysPath.basename(pp);\r\n\r\n  // ensure empty dirs get tracked\r\n  if (isDir) this.fsw._getWatchedDir(pp);\r\n  if (dirObj.has(base)) return;\r\n  dirObj.add(base);\r\n\r\n  if (!opts.ignoreInitial || forceAdd === true) {\r\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\r\n  }\r\n}\r\n\r\ninitWatch(realPath, path, wh, processPath) {\r\n  if (this.fsw.closed) return;\r\n  const closer = this._watchWithFsEvents(\r\n    wh.watchPath,\r\n    sysPath.resolve(realPath || wh.watchPath),\r\n    processPath,\r\n    wh.globFilter\r\n  );\r\n  this.fsw._addPathCloser(path, closer);\r\n}\r\n\r\n/**\r\n * Handle added path with fsevents\r\n * @param {String} path file/dir path or glob pattern\r\n * @param {Function|Boolean=} transform converts working path to what the user expects\r\n * @param {Boolean=} forceAdd ensure add is emitted\r\n * @param {Number=} priorDepth Level of subdirectories already traversed.\r\n * @returns {Promise<void>}\r\n */\r\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\r\n  if (this.fsw.closed) {\r\n    return;\r\n  }\r\n  const opts = this.fsw.options;\r\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\r\n\r\n  const wh = this.fsw._getWatchHelpers(path);\r\n\r\n  // evaluate what is at the path we're being asked to watch\r\n  try {\r\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\r\n    if (this.fsw.closed) return;\r\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\r\n      throw null;\r\n    }\r\n    if (stats.isDirectory()) {\r\n      // emit addDir unless this is a glob parent\r\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\r\n\r\n      // don't recurse further if it would exceed depth setting\r\n      if (priorDepth && priorDepth > opts.depth) return;\r\n\r\n      // scan the contents of the dir\r\n      this.fsw._readdirp(wh.watchPath, {\r\n        fileFilter: entry => wh.filterPath(entry),\r\n        directoryFilter: entry => wh.filterDir(entry),\r\n        ...Depth(opts.depth - (priorDepth || 0))\r\n      }).on(STR_DATA, (entry) => {\r\n        // need to check filterPath on dirs b/c filterDir is less restrictive\r\n        if (this.fsw.closed) {\r\n          return;\r\n        }\r\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\r\n\r\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\r\n        const {fullPath} = entry;\r\n\r\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\r\n          // preserve the current depth here since it can't be derived from\r\n          // real paths past the symlink\r\n          const curDepth = opts.depth === undefined ?\r\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\r\n\r\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\r\n        } else {\r\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\r\n        }\r\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\r\n        this.fsw._emitReady();\r\n      });\r\n    } else {\r\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\r\n      this.fsw._emitReady();\r\n    }\r\n  } catch (error) {\r\n    if (!error || this.fsw._handleError(error)) {\r\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\r\n      this.fsw._emitReady();\r\n      this.fsw._emitReady();\r\n    }\r\n  }\r\n\r\n  if (opts.persistent && forceAdd !== true) {\r\n    if (typeof transform === FUNCTION_TYPE) {\r\n      // realpath has already been resolved\r\n      this.initWatch(undefined, path, wh, processPath);\r\n    } else {\r\n      let realPath;\r\n      try {\r\n        realPath = await realpath(wh.watchPath);\r\n      } catch (e) {}\r\n      this.initWatch(realPath, path, wh, processPath);\r\n    }\r\n  }\r\n}\r\n\r\n}\r\n\r\nmodule.exports = FsEventsHandler;\r\nmodule.exports.canUse = canUse;\r\n"]},"metadata":{},"sourceType":"script"}