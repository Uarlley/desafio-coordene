{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _objectSpread = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _toConsumableArray = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.sort.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.regexp.constructor.js\");\n\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.sticky.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/es.string.repeat.js\");\n\nvar constants = require('./constants');\n\nvar utils = require('./utils');\n/**\r\n * Constants\r\n */\n\n\nvar MAX_LENGTH = constants.MAX_LENGTH,\n    POSIX_REGEX_SOURCE = constants.POSIX_REGEX_SOURCE,\n    REGEX_NON_SPECIAL_CHARS = constants.REGEX_NON_SPECIAL_CHARS,\n    REGEX_SPECIAL_CHARS_BACKREF = constants.REGEX_SPECIAL_CHARS_BACKREF,\n    REPLACEMENTS = constants.REPLACEMENTS;\n/**\r\n * Helpers\r\n */\n\nvar expandRange = function expandRange(args, options) {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange.apply(options, _toConsumableArray(args).concat([options]));\n  }\n\n  args.sort();\n  var value = \"[\".concat(args.join('-'), \"]\");\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(function (v) {\n      return utils.escapeRegex(v);\n    }).join('..');\n  }\n\n  return value;\n};\n/**\r\n * Create the message for a syntax error\r\n */\n\n\nvar syntaxError = function syntaxError(type, char) {\n  return \"Missing \".concat(type, \": \\\"\").concat(char, \"\\\" - use \\\"\\\\\\\\\").concat(char, \"\\\" to match literal characters\");\n};\n/**\r\n * Parse the given input string.\r\n * @param {String} input\r\n * @param {Object} options\r\n * @return {Object}\r\n */\n\n\nvar parse = function parse(input, options) {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  var opts = _objectSpread({}, options);\n\n  var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  var len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(\"Input length: \".concat(len, \", exceeds maximum allowed length: \").concat(max));\n  }\n\n  var bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  var tokens = [bos];\n  var capture = opts.capture ? '' : '?:';\n  var win32 = utils.isWindows(options); // create constants based on platform, for windows or posix\n\n  var PLATFORM_CHARS = constants.globChars(win32);\n  var EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n  var DOT_LITERAL = PLATFORM_CHARS.DOT_LITERAL,\n      PLUS_LITERAL = PLATFORM_CHARS.PLUS_LITERAL,\n      SLASH_LITERAL = PLATFORM_CHARS.SLASH_LITERAL,\n      ONE_CHAR = PLATFORM_CHARS.ONE_CHAR,\n      DOTS_SLASH = PLATFORM_CHARS.DOTS_SLASH,\n      NO_DOT = PLATFORM_CHARS.NO_DOT,\n      NO_DOT_SLASH = PLATFORM_CHARS.NO_DOT_SLASH,\n      NO_DOTS_SLASH = PLATFORM_CHARS.NO_DOTS_SLASH,\n      QMARK = PLATFORM_CHARS.QMARK,\n      QMARK_NO_DOT = PLATFORM_CHARS.QMARK_NO_DOT,\n      STAR = PLATFORM_CHARS.STAR,\n      START_ANCHOR = PLATFORM_CHARS.START_ANCHOR;\n\n  var globstar = function globstar(opts) {\n    return \"(\".concat(capture, \"(?:(?!\").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, \").)*?)\");\n  };\n\n  var nodot = opts.dot ? '' : NO_DOT;\n  var qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  var star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = \"(\".concat(star, \")\");\n  } // minimatch options support\n\n\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  var state = {\n    input: input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens: tokens\n  };\n  input = utils.removePrefix(input, state);\n  len = input.length;\n  var extglobs = [];\n  var braces = [];\n  var stack = [];\n  var prev = bos;\n  var value;\n  /**\r\n   * Tokenizing helpers\r\n   */\n\n  var eos = function eos() {\n    return state.index === len - 1;\n  };\n\n  var peek = state.peek = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return input[state.index + n];\n  };\n\n  var advance = state.advance = function () {\n    return input[++state.index] || '';\n  };\n\n  var remaining = function remaining() {\n    return input.slice(state.index + 1);\n  };\n\n  var consume = function consume() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var num = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    state.consumed += value;\n    state.index += num;\n  };\n\n  var append = function append(token) {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  var negate = function negate() {\n    var count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  var increment = function increment(type) {\n    state[type]++;\n    stack.push(type);\n  };\n\n  var decrement = function decrement(type) {\n    state[type]--;\n    stack.pop();\n  };\n  /**\r\n   * Push tokens onto the tokens array. This helper speeds up\r\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\r\n   * and 2) helping us avoid creating extra tokens when consecutive\r\n   * characters are plain text. This improves performance and simplifies\r\n   * lookbehinds.\r\n   */\n\n\n  var push = function push(tok) {\n    if (prev.type === 'globstar') {\n      var isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      var isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  var extglobOpen = function extglobOpen(type, value) {\n    var token = _objectSpread(_objectSpread({}, EXTGLOB_CHARS[value]), {}, {\n      conditions: 1,\n      inner: ''\n    });\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    var output = (opts.capture ? '(' : '') + token.open;\n    increment('parens');\n    push({\n      type: type,\n      value: value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output: output\n    });\n    extglobs.push(token);\n  };\n\n  var extglobClose = function extglobClose(token) {\n    var output = token.close + (opts.capture ? ')' : '');\n    var rest;\n\n    if (token.type === 'negate') {\n      var extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = \")$))\".concat(extglobStar);\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        var expression = parse(rest, _objectSpread(_objectSpread({}, options), {}, {\n          fastpaths: false\n        })).output;\n        output = token.close = \")\".concat(expression, \")\").concat(extglobStar, \")\");\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({\n      type: 'paren',\n      extglob: true,\n      value: value,\n      output: output\n    });\n    decrement('parens');\n  };\n  /**\r\n   * Fast paths\r\n   */\n\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    var backslashes = false;\n    var output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, function (m, esc, chars, first, rest, index) {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n\n        return star;\n      }\n\n      return esc ? m : \"\\\\\".concat(m);\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, function (m) {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n  /**\r\n   * Tokenize input until we reach end-of-string\r\n   */\n\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === \"\\0\") {\n      continue;\n    }\n    /**\r\n     * Escaped characters\r\n     */\n\n\n    if (value === '\\\\') {\n      var next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value: value\n        });\n        continue;\n      } // collapse slashes to reduce potential for exploits\n\n\n      var match = /^\\\\+/.exec(remaining());\n      var slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value: value\n        });\n        continue;\n      }\n    }\n    /**\r\n     * If we're inside a regex character class, continue\r\n     * until we reach the closing bracket.\r\n     */\n\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        var inner = prev.value.slice(1);\n\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            var idx = prev.value.lastIndexOf('[');\n            var pre = prev.value.slice(0, idx);\n\n            var _rest = prev.value.slice(idx + 2);\n\n            var posix = POSIX_REGEX_SOURCE[_rest];\n\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n\n              continue;\n            }\n          }\n        }\n      }\n\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = \"\\\\\".concat(value);\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = \"\\\\\".concat(value);\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({\n        value: value\n      });\n      continue;\n    }\n    /**\r\n     * If we're inside a quoted string, continue\r\n     * until we reach the closing double quote.\r\n     */\n\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({\n        value: value\n      });\n      continue;\n    }\n    /**\r\n     * Double quotes\r\n     */\n\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value: value\n        });\n      }\n\n      continue;\n    }\n    /**\r\n     * Parentheses\r\n     */\n\n\n    if (value === '(') {\n      increment('parens');\n      push({\n        type: 'paren',\n        value: value\n      });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      var extglob = extglobs[extglobs.length - 1];\n\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({\n        type: 'paren',\n        value: value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n    /**\r\n     * Square brackets\r\n     */\n\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = \"\\\\\".concat(value);\n      } else {\n        increment('brackets');\n      }\n\n      push({\n        type: 'bracket',\n        value: value\n      });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value: value,\n          output: \"\\\\\".concat(value)\n        });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({\n          type: 'text',\n          value: value,\n          output: \"\\\\\".concat(value)\n        });\n        continue;\n      }\n\n      decrement('brackets');\n      var prevValue = prev.value.slice(1);\n\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = \"/\".concat(value);\n      }\n\n      prev.value += value;\n      append({\n        value: value\n      }); // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      var escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      } // when the user specifies nothing, try to match both\n\n\n      prev.value = \"(\".concat(capture).concat(escaped, \"|\").concat(prev.value, \")\");\n      state.output += prev.value;\n      continue;\n    }\n    /**\r\n     * Braces\r\n     */\n\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      var open = {\n        type: 'brace',\n        value: value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      var brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({\n          type: 'text',\n          value: value,\n          output: value\n        });\n        continue;\n      }\n\n      var _output = ')';\n\n      if (brace.dots === true) {\n        var arr = tokens.slice();\n        var range = [];\n\n        for (var i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n\n          if (arr[i].type === 'brace') {\n            break;\n          }\n\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        _output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        var out = state.output.slice(0, brace.outputIndex);\n        var toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = _output = '\\\\}';\n        state.output = out;\n\n        var _iterator = _createForOfIteratorHelper(toks),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var t = _step.value;\n            state.output += t.output || t.value;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      push({\n        type: 'brace',\n        value: value,\n        output: _output\n      });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n    /**\r\n     * Pipes\r\n     */\n\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n\n      push({\n        type: 'text',\n        value: value\n      });\n      continue;\n    }\n    /**\r\n     * Commas\r\n     */\n\n\n    if (value === ',') {\n      var _output2 = value;\n      var _brace = braces[braces.length - 1];\n\n      if (_brace && stack[stack.length - 1] === 'braces') {\n        _brace.comma = true;\n        _output2 = '|';\n      }\n\n      push({\n        type: 'comma',\n        value: value,\n        output: _output2\n      });\n      continue;\n    }\n    /**\r\n     * Slashes\r\n     */\n\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n\n        continue;\n      }\n\n      push({\n        type: 'slash',\n        value: value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n    /**\r\n     * Dots\r\n     */\n\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        var _brace2 = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        _brace2.dots = true;\n        continue;\n      }\n\n      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({\n          type: 'text',\n          value: value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value: value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n    /**\r\n     * Question marks\r\n     */\n\n\n    if (value === '?') {\n      var isGroup = prev && prev.value === '(';\n\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        var _next = peek();\n\n        var _output3 = value;\n\n        if (_next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if (prev.value === '(' && !/[!=<:]/.test(_next) || _next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n          _output3 = \"\\\\\".concat(value);\n        }\n\n        push({\n          type: 'text',\n          value: value,\n          output: _output3\n        });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value: value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n\n      push({\n        type: 'qmark',\n        value: value,\n        output: QMARK\n      });\n      continue;\n    }\n    /**\r\n     * Exclamation\r\n     */\n\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n    /**\r\n     * Plus\r\n     */\n\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if (prev && prev.value === '(' || opts.regex === false) {\n        push({\n          type: 'plus',\n          value: value,\n          output: PLUS_LITERAL\n        });\n        continue;\n      }\n\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n        push({\n          type: 'plus',\n          value: value\n        });\n        continue;\n      }\n\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n    /**\r\n     * Plain text\r\n     */\n\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          extglob: true,\n          value: value,\n          output: ''\n        });\n        continue;\n      }\n\n      push({\n        type: 'text',\n        value: value\n      });\n      continue;\n    }\n    /**\r\n     * Plain text\r\n     */\n\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = \"\\\\\".concat(value);\n      }\n\n      var _match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n\n      if (_match) {\n        value += _match[0];\n        state.index += _match[0].length;\n      }\n\n      push({\n        type: 'text',\n        value: value\n      });\n      continue;\n    }\n    /**\r\n     * Stars\r\n     */\n\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    var rest = remaining();\n\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      var prior = prev.prev;\n      var before = prior.prev;\n      var isStart = prior.type === 'slash' || prior.type === 'bos';\n      var afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n        push({\n          type: 'star',\n          value: value,\n          output: ''\n        });\n        continue;\n      }\n\n      var isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      var isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value: value,\n          output: ''\n        });\n        continue;\n      } // strip consecutive `/**/`\n\n\n      while (rest.slice(0, 3) === '/**') {\n        var after = input[state.index + 4];\n\n        if (after && after !== '/') {\n          break;\n        }\n\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = \"(?:\".concat(prior.output);\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        var end = rest[1] !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = \"(?:\".concat(prior.output);\n        prev.type = 'globstar';\n        prev.output = \"\".concat(globstar(opts)).concat(SLASH_LITERAL, \"|\").concat(SLASH_LITERAL).concat(end, \")\");\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = \"(?:^|\".concat(SLASH_LITERAL, \"|\").concat(globstar(opts)).concat(SLASH_LITERAL, \")\");\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      } // remove single star from output\n\n\n      state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar\n\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value; // reset output with globstar\n\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    var token = {\n      type: 'star',\n      value: value,\n      output: star\n    };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: \"\".concat(SLASH_LITERAL, \"?\")\n    });\n  } // rebuild the output if we had to backtrack at any point\n\n\n  if (state.backtrack === true) {\n    state.output = '';\n\n    var _iterator2 = _createForOfIteratorHelper(state.tokens),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _token = _step2.value;\n        state.output += _token.output != null ? _token.output : _token.value;\n\n        if (_token.suffix) {\n          state.output += _token.suffix;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return state;\n};\n/**\r\n * Fast paths for creating regular expressions for common glob patterns.\r\n * This can significantly speed up processing and has very little downside\r\n * impact when none of the fast paths match.\r\n */\n\n\nparse.fastpaths = function (input, options) {\n  var opts = _objectSpread({}, options);\n\n  var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  var len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(\"Input length: \".concat(len, \", exceeds maximum allowed length: \").concat(max));\n  }\n\n  input = REPLACEMENTS[input] || input;\n  var win32 = utils.isWindows(options); // create constants based on platform, for windows or posix\n\n  var _constants$globChars = constants.globChars(win32),\n      DOT_LITERAL = _constants$globChars.DOT_LITERAL,\n      SLASH_LITERAL = _constants$globChars.SLASH_LITERAL,\n      ONE_CHAR = _constants$globChars.ONE_CHAR,\n      DOTS_SLASH = _constants$globChars.DOTS_SLASH,\n      NO_DOT = _constants$globChars.NO_DOT,\n      NO_DOTS = _constants$globChars.NO_DOTS,\n      NO_DOTS_SLASH = _constants$globChars.NO_DOTS_SLASH,\n      STAR = _constants$globChars.STAR,\n      START_ANCHOR = _constants$globChars.START_ANCHOR;\n\n  var nodot = opts.dot ? NO_DOTS : NO_DOT;\n  var slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  var capture = opts.capture ? '' : '?:';\n  var state = {\n    negated: false,\n    prefix: ''\n  };\n  var star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = \"(\".concat(star, \")\");\n  }\n\n  var globstar = function globstar(opts) {\n    if (opts.noglobstar === true) return star;\n    return \"(\".concat(capture, \"(?:(?!\").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, \").)*?)\");\n  };\n\n  var create = function create(str) {\n    switch (str) {\n      case '*':\n        return \"\".concat(nodot).concat(ONE_CHAR).concat(star);\n\n      case '.*':\n        return \"\".concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);\n\n      case '*.*':\n        return \"\".concat(nodot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);\n\n      case '*/*':\n        return \"\".concat(nodot).concat(star).concat(SLASH_LITERAL).concat(ONE_CHAR).concat(slashDot).concat(star);\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return \"(?:\".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, \")?\").concat(slashDot).concat(ONE_CHAR).concat(star);\n\n      case '**/*.*':\n        return \"(?:\".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, \")?\").concat(slashDot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);\n\n      case '**/.*':\n        return \"(?:\".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, \")?\").concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);\n\n      default:\n        {\n          var match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n\n          var _source = create(match[1]);\n\n          if (!_source) return;\n          return _source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n\n  var output = utils.removePrefix(input, state);\n  var source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += \"\".concat(SLASH_LITERAL, \"?\");\n  }\n\n  return source;\n};\n\nmodule.exports = parse;","map":{"version":3,"sources":["C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/picomatch/lib/parse.js"],"names":["constants","require","utils","MAX_LENGTH","POSIX_REGEX_SOURCE","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REPLACEMENTS","expandRange","args","options","sort","value","join","RegExp","ex","map","v","escapeRegex","syntaxError","type","char","parse","input","TypeError","opts","max","maxLength","Math","min","len","length","SyntaxError","bos","output","prepend","tokens","capture","win32","isWindows","PLATFORM_CHARS","globChars","EXTGLOB_CHARS","extglobChars","DOT_LITERAL","PLUS_LITERAL","SLASH_LITERAL","ONE_CHAR","DOTS_SLASH","NO_DOT","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK","QMARK_NO_DOT","STAR","START_ANCHOR","globstar","dot","nodot","qmarkNoDot","star","bash","noext","noextglob","state","index","start","consumed","prefix","backtrack","negated","brackets","braces","parens","quotes","removePrefix","extglobs","stack","prev","eos","peek","n","advance","remaining","slice","consume","num","append","token","negate","count","increment","push","decrement","pop","tok","isBrace","isExtglob","extglob","inner","extglobOpen","conditions","open","extglobClose","close","rest","extglobStar","includes","test","expression","fastpaths","negatedExtglob","backslashes","replace","m","esc","chars","first","repeat","unescape","contains","wrapOutput","next","match","exec","slashes","posix","idx","lastIndexOf","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","hasRegexChars","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","i","unshift","comma","out","toks","t","isGroup","supportsLookbehinds","Error","nonegate","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","escapeLast","suffix","NO_DOTS","slashDot","create","str","source","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst constants = require('./constants');\r\nconst utils = require('./utils');\r\n\r\n/**\r\n * Constants\r\n */\r\n\r\nconst {\r\n  MAX_LENGTH,\r\n  POSIX_REGEX_SOURCE,\r\n  REGEX_NON_SPECIAL_CHARS,\r\n  REGEX_SPECIAL_CHARS_BACKREF,\r\n  REPLACEMENTS\r\n} = constants;\r\n\r\n/**\r\n * Helpers\r\n */\r\n\r\nconst expandRange = (args, options) => {\r\n  if (typeof options.expandRange === 'function') {\r\n    return options.expandRange(...args, options);\r\n  }\r\n\r\n  args.sort();\r\n  const value = `[${args.join('-')}]`;\r\n\r\n  try {\r\n    /* eslint-disable-next-line no-new */\r\n    new RegExp(value);\r\n  } catch (ex) {\r\n    return args.map(v => utils.escapeRegex(v)).join('..');\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\n/**\r\n * Create the message for a syntax error\r\n */\r\n\r\nconst syntaxError = (type, char) => {\r\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\r\n};\r\n\r\n/**\r\n * Parse the given input string.\r\n * @param {String} input\r\n * @param {Object} options\r\n * @return {Object}\r\n */\r\n\r\nconst parse = (input, options) => {\r\n  if (typeof input !== 'string') {\r\n    throw new TypeError('Expected a string');\r\n  }\r\n\r\n  input = REPLACEMENTS[input] || input;\r\n\r\n  const opts = { ...options };\r\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\r\n\r\n  let len = input.length;\r\n  if (len > max) {\r\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\r\n  }\r\n\r\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\r\n  const tokens = [bos];\r\n\r\n  const capture = opts.capture ? '' : '?:';\r\n  const win32 = utils.isWindows(options);\r\n\r\n  // create constants based on platform, for windows or posix\r\n  const PLATFORM_CHARS = constants.globChars(win32);\r\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\r\n\r\n  const {\r\n    DOT_LITERAL,\r\n    PLUS_LITERAL,\r\n    SLASH_LITERAL,\r\n    ONE_CHAR,\r\n    DOTS_SLASH,\r\n    NO_DOT,\r\n    NO_DOT_SLASH,\r\n    NO_DOTS_SLASH,\r\n    QMARK,\r\n    QMARK_NO_DOT,\r\n    STAR,\r\n    START_ANCHOR\r\n  } = PLATFORM_CHARS;\r\n\r\n  const globstar = opts => {\r\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\r\n  };\r\n\r\n  const nodot = opts.dot ? '' : NO_DOT;\r\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\r\n  let star = opts.bash === true ? globstar(opts) : STAR;\r\n\r\n  if (opts.capture) {\r\n    star = `(${star})`;\r\n  }\r\n\r\n  // minimatch options support\r\n  if (typeof opts.noext === 'boolean') {\r\n    opts.noextglob = opts.noext;\r\n  }\r\n\r\n  const state = {\r\n    input,\r\n    index: -1,\r\n    start: 0,\r\n    dot: opts.dot === true,\r\n    consumed: '',\r\n    output: '',\r\n    prefix: '',\r\n    backtrack: false,\r\n    negated: false,\r\n    brackets: 0,\r\n    braces: 0,\r\n    parens: 0,\r\n    quotes: 0,\r\n    globstar: false,\r\n    tokens\r\n  };\r\n\r\n  input = utils.removePrefix(input, state);\r\n  len = input.length;\r\n\r\n  const extglobs = [];\r\n  const braces = [];\r\n  const stack = [];\r\n  let prev = bos;\r\n  let value;\r\n\r\n  /**\r\n   * Tokenizing helpers\r\n   */\r\n\r\n  const eos = () => state.index === len - 1;\r\n  const peek = state.peek = (n = 1) => input[state.index + n];\r\n  const advance = state.advance = () => input[++state.index] || '';\r\n  const remaining = () => input.slice(state.index + 1);\r\n  const consume = (value = '', num = 0) => {\r\n    state.consumed += value;\r\n    state.index += num;\r\n  };\r\n\r\n  const append = token => {\r\n    state.output += token.output != null ? token.output : token.value;\r\n    consume(token.value);\r\n  };\r\n\r\n  const negate = () => {\r\n    let count = 1;\r\n\r\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\r\n      advance();\r\n      state.start++;\r\n      count++;\r\n    }\r\n\r\n    if (count % 2 === 0) {\r\n      return false;\r\n    }\r\n\r\n    state.negated = true;\r\n    state.start++;\r\n    return true;\r\n  };\r\n\r\n  const increment = type => {\r\n    state[type]++;\r\n    stack.push(type);\r\n  };\r\n\r\n  const decrement = type => {\r\n    state[type]--;\r\n    stack.pop();\r\n  };\r\n\r\n  /**\r\n   * Push tokens onto the tokens array. This helper speeds up\r\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\r\n   * and 2) helping us avoid creating extra tokens when consecutive\r\n   * characters are plain text. This improves performance and simplifies\r\n   * lookbehinds.\r\n   */\r\n\r\n  const push = tok => {\r\n    if (prev.type === 'globstar') {\r\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\r\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\r\n\r\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\r\n        state.output = state.output.slice(0, -prev.output.length);\r\n        prev.type = 'star';\r\n        prev.value = '*';\r\n        prev.output = star;\r\n        state.output += prev.output;\r\n      }\r\n    }\r\n\r\n    if (extglobs.length && tok.type !== 'paren') {\r\n      extglobs[extglobs.length - 1].inner += tok.value;\r\n    }\r\n\r\n    if (tok.value || tok.output) append(tok);\r\n    if (prev && prev.type === 'text' && tok.type === 'text') {\r\n      prev.value += tok.value;\r\n      prev.output = (prev.output || '') + tok.value;\r\n      return;\r\n    }\r\n\r\n    tok.prev = prev;\r\n    tokens.push(tok);\r\n    prev = tok;\r\n  };\r\n\r\n  const extglobOpen = (type, value) => {\r\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\r\n\r\n    token.prev = prev;\r\n    token.parens = state.parens;\r\n    token.output = state.output;\r\n    const output = (opts.capture ? '(' : '') + token.open;\r\n\r\n    increment('parens');\r\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\r\n    push({ type: 'paren', extglob: true, value: advance(), output });\r\n    extglobs.push(token);\r\n  };\r\n\r\n  const extglobClose = token => {\r\n    let output = token.close + (opts.capture ? ')' : '');\r\n    let rest;\r\n\r\n    if (token.type === 'negate') {\r\n      let extglobStar = star;\r\n\r\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\r\n        extglobStar = globstar(opts);\r\n      }\r\n\r\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\r\n        output = token.close = `)$))${extglobStar}`;\r\n      }\r\n\r\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\r\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\r\n        // In this case, we need to parse the string and use it in the output of the original pattern.\r\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\r\n        //\r\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\r\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\r\n\r\n        output = token.close = `)${expression})${extglobStar})`;\r\n      }\r\n\r\n      if (token.prev.type === 'bos') {\r\n        state.negatedExtglob = true;\r\n      }\r\n    }\r\n\r\n    push({ type: 'paren', extglob: true, value, output });\r\n    decrement('parens');\r\n  };\r\n\r\n  /**\r\n   * Fast paths\r\n   */\r\n\r\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\r\n    let backslashes = false;\r\n\r\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\r\n      if (first === '\\\\') {\r\n        backslashes = true;\r\n        return m;\r\n      }\r\n\r\n      if (first === '?') {\r\n        if (esc) {\r\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\r\n        }\r\n        if (index === 0) {\r\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\r\n        }\r\n        return QMARK.repeat(chars.length);\r\n      }\r\n\r\n      if (first === '.') {\r\n        return DOT_LITERAL.repeat(chars.length);\r\n      }\r\n\r\n      if (first === '*') {\r\n        if (esc) {\r\n          return esc + first + (rest ? star : '');\r\n        }\r\n        return star;\r\n      }\r\n      return esc ? m : `\\\\${m}`;\r\n    });\r\n\r\n    if (backslashes === true) {\r\n      if (opts.unescape === true) {\r\n        output = output.replace(/\\\\/g, '');\r\n      } else {\r\n        output = output.replace(/\\\\+/g, m => {\r\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\r\n        });\r\n      }\r\n    }\r\n\r\n    if (output === input && opts.contains === true) {\r\n      state.output = input;\r\n      return state;\r\n    }\r\n\r\n    state.output = utils.wrapOutput(output, state, options);\r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * Tokenize input until we reach end-of-string\r\n   */\r\n\r\n  while (!eos()) {\r\n    value = advance();\r\n\r\n    if (value === '\\u0000') {\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Escaped characters\r\n     */\r\n\r\n    if (value === '\\\\') {\r\n      const next = peek();\r\n\r\n      if (next === '/' && opts.bash !== true) {\r\n        continue;\r\n      }\r\n\r\n      if (next === '.' || next === ';') {\r\n        continue;\r\n      }\r\n\r\n      if (!next) {\r\n        value += '\\\\';\r\n        push({ type: 'text', value });\r\n        continue;\r\n      }\r\n\r\n      // collapse slashes to reduce potential for exploits\r\n      const match = /^\\\\+/.exec(remaining());\r\n      let slashes = 0;\r\n\r\n      if (match && match[0].length > 2) {\r\n        slashes = match[0].length;\r\n        state.index += slashes;\r\n        if (slashes % 2 !== 0) {\r\n          value += '\\\\';\r\n        }\r\n      }\r\n\r\n      if (opts.unescape === true) {\r\n        value = advance();\r\n      } else {\r\n        value += advance();\r\n      }\r\n\r\n      if (state.brackets === 0) {\r\n        push({ type: 'text', value });\r\n        continue;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * If we're inside a regex character class, continue\r\n     * until we reach the closing bracket.\r\n     */\r\n\r\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\r\n      if (opts.posix !== false && value === ':') {\r\n        const inner = prev.value.slice(1);\r\n        if (inner.includes('[')) {\r\n          prev.posix = true;\r\n\r\n          if (inner.includes(':')) {\r\n            const idx = prev.value.lastIndexOf('[');\r\n            const pre = prev.value.slice(0, idx);\r\n            const rest = prev.value.slice(idx + 2);\r\n            const posix = POSIX_REGEX_SOURCE[rest];\r\n            if (posix) {\r\n              prev.value = pre + posix;\r\n              state.backtrack = true;\r\n              advance();\r\n\r\n              if (!bos.output && tokens.indexOf(prev) === 1) {\r\n                bos.output = ONE_CHAR;\r\n              }\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\r\n        value = `\\\\${value}`;\r\n      }\r\n\r\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\r\n        value = `\\\\${value}`;\r\n      }\r\n\r\n      if (opts.posix === true && value === '!' && prev.value === '[') {\r\n        value = '^';\r\n      }\r\n\r\n      prev.value += value;\r\n      append({ value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * If we're inside a quoted string, continue\r\n     * until we reach the closing double quote.\r\n     */\r\n\r\n    if (state.quotes === 1 && value !== '\"') {\r\n      value = utils.escapeRegex(value);\r\n      prev.value += value;\r\n      append({ value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Double quotes\r\n     */\r\n\r\n    if (value === '\"') {\r\n      state.quotes = state.quotes === 1 ? 0 : 1;\r\n      if (opts.keepQuotes === true) {\r\n        push({ type: 'text', value });\r\n      }\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Parentheses\r\n     */\r\n\r\n    if (value === '(') {\r\n      increment('parens');\r\n      push({ type: 'paren', value });\r\n      continue;\r\n    }\r\n\r\n    if (value === ')') {\r\n      if (state.parens === 0 && opts.strictBrackets === true) {\r\n        throw new SyntaxError(syntaxError('opening', '('));\r\n      }\r\n\r\n      const extglob = extglobs[extglobs.length - 1];\r\n      if (extglob && state.parens === extglob.parens + 1) {\r\n        extglobClose(extglobs.pop());\r\n        continue;\r\n      }\r\n\r\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\r\n      decrement('parens');\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Square brackets\r\n     */\r\n\r\n    if (value === '[') {\r\n      if (opts.nobracket === true || !remaining().includes(']')) {\r\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\r\n          throw new SyntaxError(syntaxError('closing', ']'));\r\n        }\r\n\r\n        value = `\\\\${value}`;\r\n      } else {\r\n        increment('brackets');\r\n      }\r\n\r\n      push({ type: 'bracket', value });\r\n      continue;\r\n    }\r\n\r\n    if (value === ']') {\r\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\r\n        push({ type: 'text', value, output: `\\\\${value}` });\r\n        continue;\r\n      }\r\n\r\n      if (state.brackets === 0) {\r\n        if (opts.strictBrackets === true) {\r\n          throw new SyntaxError(syntaxError('opening', '['));\r\n        }\r\n\r\n        push({ type: 'text', value, output: `\\\\${value}` });\r\n        continue;\r\n      }\r\n\r\n      decrement('brackets');\r\n\r\n      const prevValue = prev.value.slice(1);\r\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\r\n        value = `/${value}`;\r\n      }\r\n\r\n      prev.value += value;\r\n      append({ value });\r\n\r\n      // when literal brackets are explicitly disabled\r\n      // assume we should match with a regex character class\r\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\r\n        continue;\r\n      }\r\n\r\n      const escaped = utils.escapeRegex(prev.value);\r\n      state.output = state.output.slice(0, -prev.value.length);\r\n\r\n      // when literal brackets are explicitly enabled\r\n      // assume we should escape the brackets to match literal characters\r\n      if (opts.literalBrackets === true) {\r\n        state.output += escaped;\r\n        prev.value = escaped;\r\n        continue;\r\n      }\r\n\r\n      // when the user specifies nothing, try to match both\r\n      prev.value = `(${capture}${escaped}|${prev.value})`;\r\n      state.output += prev.value;\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Braces\r\n     */\r\n\r\n    if (value === '{' && opts.nobrace !== true) {\r\n      increment('braces');\r\n\r\n      const open = {\r\n        type: 'brace',\r\n        value,\r\n        output: '(',\r\n        outputIndex: state.output.length,\r\n        tokensIndex: state.tokens.length\r\n      };\r\n\r\n      braces.push(open);\r\n      push(open);\r\n      continue;\r\n    }\r\n\r\n    if (value === '}') {\r\n      const brace = braces[braces.length - 1];\r\n\r\n      if (opts.nobrace === true || !brace) {\r\n        push({ type: 'text', value, output: value });\r\n        continue;\r\n      }\r\n\r\n      let output = ')';\r\n\r\n      if (brace.dots === true) {\r\n        const arr = tokens.slice();\r\n        const range = [];\r\n\r\n        for (let i = arr.length - 1; i >= 0; i--) {\r\n          tokens.pop();\r\n          if (arr[i].type === 'brace') {\r\n            break;\r\n          }\r\n          if (arr[i].type !== 'dots') {\r\n            range.unshift(arr[i].value);\r\n          }\r\n        }\r\n\r\n        output = expandRange(range, opts);\r\n        state.backtrack = true;\r\n      }\r\n\r\n      if (brace.comma !== true && brace.dots !== true) {\r\n        const out = state.output.slice(0, brace.outputIndex);\r\n        const toks = state.tokens.slice(brace.tokensIndex);\r\n        brace.value = brace.output = '\\\\{';\r\n        value = output = '\\\\}';\r\n        state.output = out;\r\n        for (const t of toks) {\r\n          state.output += (t.output || t.value);\r\n        }\r\n      }\r\n\r\n      push({ type: 'brace', value, output });\r\n      decrement('braces');\r\n      braces.pop();\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Pipes\r\n     */\r\n\r\n    if (value === '|') {\r\n      if (extglobs.length > 0) {\r\n        extglobs[extglobs.length - 1].conditions++;\r\n      }\r\n      push({ type: 'text', value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Commas\r\n     */\r\n\r\n    if (value === ',') {\r\n      let output = value;\r\n\r\n      const brace = braces[braces.length - 1];\r\n      if (brace && stack[stack.length - 1] === 'braces') {\r\n        brace.comma = true;\r\n        output = '|';\r\n      }\r\n\r\n      push({ type: 'comma', value, output });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Slashes\r\n     */\r\n\r\n    if (value === '/') {\r\n      // if the beginning of the glob is \"./\", advance the start\r\n      // to the current index, and don't add the \"./\" characters\r\n      // to the state. This greatly simplifies lookbehinds when\r\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\r\n      if (prev.type === 'dot' && state.index === state.start + 1) {\r\n        state.start = state.index + 1;\r\n        state.consumed = '';\r\n        state.output = '';\r\n        tokens.pop();\r\n        prev = bos; // reset \"prev\" to the first token\r\n        continue;\r\n      }\r\n\r\n      push({ type: 'slash', value, output: SLASH_LITERAL });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Dots\r\n     */\r\n\r\n    if (value === '.') {\r\n      if (state.braces > 0 && prev.type === 'dot') {\r\n        if (prev.value === '.') prev.output = DOT_LITERAL;\r\n        const brace = braces[braces.length - 1];\r\n        prev.type = 'dots';\r\n        prev.output += value;\r\n        prev.value += value;\r\n        brace.dots = true;\r\n        continue;\r\n      }\r\n\r\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\r\n        push({ type: 'text', value, output: DOT_LITERAL });\r\n        continue;\r\n      }\r\n\r\n      push({ type: 'dot', value, output: DOT_LITERAL });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Question marks\r\n     */\r\n\r\n    if (value === '?') {\r\n      const isGroup = prev && prev.value === '(';\r\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n        extglobOpen('qmark', value);\r\n        continue;\r\n      }\r\n\r\n      if (prev && prev.type === 'paren') {\r\n        const next = peek();\r\n        let output = value;\r\n\r\n        if (next === '<' && !utils.supportsLookbehinds()) {\r\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\r\n        }\r\n\r\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\r\n          output = `\\\\${value}`;\r\n        }\r\n\r\n        push({ type: 'text', value, output });\r\n        continue;\r\n      }\r\n\r\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\r\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\r\n        continue;\r\n      }\r\n\r\n      push({ type: 'qmark', value, output: QMARK });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Exclamation\r\n     */\r\n\r\n    if (value === '!') {\r\n      if (opts.noextglob !== true && peek() === '(') {\r\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\r\n          extglobOpen('negate', value);\r\n          continue;\r\n        }\r\n      }\r\n\r\n      if (opts.nonegate !== true && state.index === 0) {\r\n        negate();\r\n        continue;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Plus\r\n     */\r\n\r\n    if (value === '+') {\r\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n        extglobOpen('plus', value);\r\n        continue;\r\n      }\r\n\r\n      if ((prev && prev.value === '(') || opts.regex === false) {\r\n        push({ type: 'plus', value, output: PLUS_LITERAL });\r\n        continue;\r\n      }\r\n\r\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\r\n        push({ type: 'plus', value });\r\n        continue;\r\n      }\r\n\r\n      push({ type: 'plus', value: PLUS_LITERAL });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Plain text\r\n     */\r\n\r\n    if (value === '@') {\r\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n        push({ type: 'at', extglob: true, value, output: '' });\r\n        continue;\r\n      }\r\n\r\n      push({ type: 'text', value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Plain text\r\n     */\r\n\r\n    if (value !== '*') {\r\n      if (value === '$' || value === '^') {\r\n        value = `\\\\${value}`;\r\n      }\r\n\r\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\r\n      if (match) {\r\n        value += match[0];\r\n        state.index += match[0].length;\r\n      }\r\n\r\n      push({ type: 'text', value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Stars\r\n     */\r\n\r\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\r\n      prev.type = 'star';\r\n      prev.star = true;\r\n      prev.value += value;\r\n      prev.output = star;\r\n      state.backtrack = true;\r\n      state.globstar = true;\r\n      consume(value);\r\n      continue;\r\n    }\r\n\r\n    let rest = remaining();\r\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\r\n      extglobOpen('star', value);\r\n      continue;\r\n    }\r\n\r\n    if (prev.type === 'star') {\r\n      if (opts.noglobstar === true) {\r\n        consume(value);\r\n        continue;\r\n      }\r\n\r\n      const prior = prev.prev;\r\n      const before = prior.prev;\r\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\r\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\r\n\r\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\r\n        push({ type: 'star', value, output: '' });\r\n        continue;\r\n      }\r\n\r\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\r\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\r\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\r\n        push({ type: 'star', value, output: '' });\r\n        continue;\r\n      }\r\n\r\n      // strip consecutive `/**/`\r\n      while (rest.slice(0, 3) === '/**') {\r\n        const after = input[state.index + 4];\r\n        if (after && after !== '/') {\r\n          break;\r\n        }\r\n        rest = rest.slice(3);\r\n        consume('/**', 3);\r\n      }\r\n\r\n      if (prior.type === 'bos' && eos()) {\r\n        prev.type = 'globstar';\r\n        prev.value += value;\r\n        prev.output = globstar(opts);\r\n        state.output = prev.output;\r\n        state.globstar = true;\r\n        consume(value);\r\n        continue;\r\n      }\r\n\r\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\r\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\r\n        prior.output = `(?:${prior.output}`;\r\n\r\n        prev.type = 'globstar';\r\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\r\n        prev.value += value;\r\n        state.globstar = true;\r\n        state.output += prior.output + prev.output;\r\n        consume(value);\r\n        continue;\r\n      }\r\n\r\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\r\n        const end = rest[1] !== void 0 ? '|$' : '';\r\n\r\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\r\n        prior.output = `(?:${prior.output}`;\r\n\r\n        prev.type = 'globstar';\r\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\r\n        prev.value += value;\r\n\r\n        state.output += prior.output + prev.output;\r\n        state.globstar = true;\r\n\r\n        consume(value + advance());\r\n\r\n        push({ type: 'slash', value: '/', output: '' });\r\n        continue;\r\n      }\r\n\r\n      if (prior.type === 'bos' && rest[0] === '/') {\r\n        prev.type = 'globstar';\r\n        prev.value += value;\r\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\r\n        state.output = prev.output;\r\n        state.globstar = true;\r\n        consume(value + advance());\r\n        push({ type: 'slash', value: '/', output: '' });\r\n        continue;\r\n      }\r\n\r\n      // remove single star from output\r\n      state.output = state.output.slice(0, -prev.output.length);\r\n\r\n      // reset previous token to globstar\r\n      prev.type = 'globstar';\r\n      prev.output = globstar(opts);\r\n      prev.value += value;\r\n\r\n      // reset output with globstar\r\n      state.output += prev.output;\r\n      state.globstar = true;\r\n      consume(value);\r\n      continue;\r\n    }\r\n\r\n    const token = { type: 'star', value, output: star };\r\n\r\n    if (opts.bash === true) {\r\n      token.output = '.*?';\r\n      if (prev.type === 'bos' || prev.type === 'slash') {\r\n        token.output = nodot + token.output;\r\n      }\r\n      push(token);\r\n      continue;\r\n    }\r\n\r\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\r\n      token.output = value;\r\n      push(token);\r\n      continue;\r\n    }\r\n\r\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\r\n      if (prev.type === 'dot') {\r\n        state.output += NO_DOT_SLASH;\r\n        prev.output += NO_DOT_SLASH;\r\n\r\n      } else if (opts.dot === true) {\r\n        state.output += NO_DOTS_SLASH;\r\n        prev.output += NO_DOTS_SLASH;\r\n\r\n      } else {\r\n        state.output += nodot;\r\n        prev.output += nodot;\r\n      }\r\n\r\n      if (peek() !== '*') {\r\n        state.output += ONE_CHAR;\r\n        prev.output += ONE_CHAR;\r\n      }\r\n    }\r\n\r\n    push(token);\r\n  }\r\n\r\n  while (state.brackets > 0) {\r\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\r\n    state.output = utils.escapeLast(state.output, '[');\r\n    decrement('brackets');\r\n  }\r\n\r\n  while (state.parens > 0) {\r\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\r\n    state.output = utils.escapeLast(state.output, '(');\r\n    decrement('parens');\r\n  }\r\n\r\n  while (state.braces > 0) {\r\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\r\n    state.output = utils.escapeLast(state.output, '{');\r\n    decrement('braces');\r\n  }\r\n\r\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\r\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\r\n  }\r\n\r\n  // rebuild the output if we had to backtrack at any point\r\n  if (state.backtrack === true) {\r\n    state.output = '';\r\n\r\n    for (const token of state.tokens) {\r\n      state.output += token.output != null ? token.output : token.value;\r\n\r\n      if (token.suffix) {\r\n        state.output += token.suffix;\r\n      }\r\n    }\r\n  }\r\n\r\n  return state;\r\n};\r\n\r\n/**\r\n * Fast paths for creating regular expressions for common glob patterns.\r\n * This can significantly speed up processing and has very little downside\r\n * impact when none of the fast paths match.\r\n */\r\n\r\nparse.fastpaths = (input, options) => {\r\n  const opts = { ...options };\r\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\r\n  const len = input.length;\r\n  if (len > max) {\r\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\r\n  }\r\n\r\n  input = REPLACEMENTS[input] || input;\r\n  const win32 = utils.isWindows(options);\r\n\r\n  // create constants based on platform, for windows or posix\r\n  const {\r\n    DOT_LITERAL,\r\n    SLASH_LITERAL,\r\n    ONE_CHAR,\r\n    DOTS_SLASH,\r\n    NO_DOT,\r\n    NO_DOTS,\r\n    NO_DOTS_SLASH,\r\n    STAR,\r\n    START_ANCHOR\r\n  } = constants.globChars(win32);\r\n\r\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\r\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\r\n  const capture = opts.capture ? '' : '?:';\r\n  const state = { negated: false, prefix: '' };\r\n  let star = opts.bash === true ? '.*?' : STAR;\r\n\r\n  if (opts.capture) {\r\n    star = `(${star})`;\r\n  }\r\n\r\n  const globstar = opts => {\r\n    if (opts.noglobstar === true) return star;\r\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\r\n  };\r\n\r\n  const create = str => {\r\n    switch (str) {\r\n      case '*':\r\n        return `${nodot}${ONE_CHAR}${star}`;\r\n\r\n      case '.*':\r\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n      case '*.*':\r\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n      case '*/*':\r\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\r\n\r\n      case '**':\r\n        return nodot + globstar(opts);\r\n\r\n      case '**/*':\r\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\r\n\r\n      case '**/*.*':\r\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n      case '**/.*':\r\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n      default: {\r\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\r\n        if (!match) return;\r\n\r\n        const source = create(match[1]);\r\n        if (!source) return;\r\n\r\n        return source + DOT_LITERAL + match[2];\r\n      }\r\n    }\r\n  };\r\n\r\n  const output = utils.removePrefix(input, state);\r\n  let source = create(output);\r\n\r\n  if (source && opts.strictSlashes !== true) {\r\n    source += `${SLASH_LITERAL}?`;\r\n  }\r\n\r\n  return source;\r\n};\r\n\r\nmodule.exports = parse;\r\n"]},"metadata":{},"sourceType":"script"}