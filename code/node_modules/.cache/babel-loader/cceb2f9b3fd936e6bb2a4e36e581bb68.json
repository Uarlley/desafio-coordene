{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.number.is-integer.js\");\n\nrequire(\"core-js/modules/es.number.constructor.js\");\n\nrequire(\"core-js/modules/es.string.trim.js\");\n\nrequire(\"core-js/modules/es.array.find.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nexports.isInteger = function (num) {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n\n  return false;\n};\n/**\r\n * Find a node of the given type\r\n */\n\n\nexports.find = function (node, type) {\n  return node.nodes.find(function (node) {\n    return node.type === type;\n  });\n};\n/**\r\n * Find a node of the given type\r\n */\n\n\nexports.exceedsLimit = function (min, max) {\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var limit = arguments.length > 3 ? arguments[3] : undefined;\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return (Number(max) - Number(min)) / Number(step) >= limit;\n};\n/**\r\n * Escape the given node with '\\\\' before node.value\r\n */\n\n\nexports.escapeNode = function (block) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var type = arguments.length > 2 ? arguments[2] : undefined;\n  var node = block.nodes[n];\n  if (!node) return;\n\n  if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n/**\r\n * Returns true if the given brace node should be enclosed in literal braces\r\n */\n\n\nexports.encloseBrace = function (node) {\n  if (node.type !== 'brace') return false;\n\n  if (node.commas >> 0 + node.ranges >> 0 === 0) {\n    node.invalid = true;\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Returns true if a brace node is invalid.\r\n */\n\n\nexports.isInvalidBrace = function (block) {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n\n  if (block.commas >> 0 + block.ranges >> 0 === 0) {\n    block.invalid = true;\n    return true;\n  }\n\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Returns true if a node is an open or close node\r\n */\n\n\nexports.isOpenOrClose = function (node) {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n\n  return node.open === true || node.close === true;\n};\n/**\r\n * Reduce an array of text nodes.\r\n */\n\n\nexports.reduce = function (nodes) {\n  return nodes.reduce(function (acc, node) {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n};\n/**\r\n * Flatten an array\r\n */\n\n\nexports.flatten = function () {\n  var result = [];\n\n  var flat = function flat(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      var ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n\n    return result;\n  };\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  flat(args);\n  return result;\n};","map":{"version":3,"sources":["C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/braces/lib/utils.js"],"names":["exports","isInteger","num","Number","trim","find","node","type","nodes","exceedsLimit","min","max","step","limit","escapeNode","block","n","escaped","value","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","open","close","isOpenOrClose","reduce","acc","push","flatten","result","flat","arr","i","length","ele","Array","isArray","args"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nexports.isInteger = num => {\r\n  if (typeof num === 'number') {\r\n    return Number.isInteger(num);\r\n  }\r\n  if (typeof num === 'string' && num.trim() !== '') {\r\n    return Number.isInteger(Number(num));\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Find a node of the given type\r\n */\r\n\r\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\r\n\r\n/**\r\n * Find a node of the given type\r\n */\r\n\r\nexports.exceedsLimit = (min, max, step = 1, limit) => {\r\n  if (limit === false) return false;\r\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\r\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\r\n};\r\n\r\n/**\r\n * Escape the given node with '\\\\' before node.value\r\n */\r\n\r\nexports.escapeNode = (block, n = 0, type) => {\r\n  let node = block.nodes[n];\r\n  if (!node) return;\r\n\r\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\r\n    if (node.escaped !== true) {\r\n      node.value = '\\\\' + node.value;\r\n      node.escaped = true;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Returns true if the given brace node should be enclosed in literal braces\r\n */\r\n\r\nexports.encloseBrace = node => {\r\n  if (node.type !== 'brace') return false;\r\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\r\n    node.invalid = true;\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if a brace node is invalid.\r\n */\r\n\r\nexports.isInvalidBrace = block => {\r\n  if (block.type !== 'brace') return false;\r\n  if (block.invalid === true || block.dollar) return true;\r\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\r\n    block.invalid = true;\r\n    return true;\r\n  }\r\n  if (block.open !== true || block.close !== true) {\r\n    block.invalid = true;\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if a node is an open or close node\r\n */\r\n\r\nexports.isOpenOrClose = node => {\r\n  if (node.type === 'open' || node.type === 'close') {\r\n    return true;\r\n  }\r\n  return node.open === true || node.close === true;\r\n};\r\n\r\n/**\r\n * Reduce an array of text nodes.\r\n */\r\n\r\nexports.reduce = nodes => nodes.reduce((acc, node) => {\r\n  if (node.type === 'text') acc.push(node.value);\r\n  if (node.type === 'range') node.type = 'text';\r\n  return acc;\r\n}, []);\r\n\r\n/**\r\n * Flatten an array\r\n */\r\n\r\nexports.flatten = (...args) => {\r\n  const result = [];\r\n  const flat = arr => {\r\n    for (let i = 0; i < arr.length; i++) {\r\n      let ele = arr[i];\r\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\r\n    }\r\n    return result;\r\n  };\r\n  flat(args);\r\n  return result;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}