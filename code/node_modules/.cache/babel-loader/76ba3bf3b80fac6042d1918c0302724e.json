{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar fill = require('fill-range');\n\nvar stringify = require('./stringify');\n\nvar utils = require('./utils');\n\nvar append = function append() {\n  var queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var stash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var enclose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(function (ele) {\n      return \"{\".concat(ele, \"}\");\n    }) : stash;\n  }\n\n  var _iterator = _createForOfIteratorHelper(queue),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n\n      if (Array.isArray(item)) {\n        var _iterator2 = _createForOfIteratorHelper(item),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var value = _step2.value;\n            result.push(append(value, stash, enclose));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        var _iterator3 = _createForOfIteratorHelper(stash),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var ele = _step3.value;\n            if (enclose === true && typeof ele === 'string') ele = \"{\".concat(ele, \"}\");\n            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return utils.flatten(result);\n};\n\nvar expand = function expand(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  var walk = function walk(node) {\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    node.queue = [];\n    var p = parent;\n    var q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      var args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit.apply(utils, _toConsumableArray(args).concat([options.step, rangeLimit]))) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      var range = fill.apply(void 0, _toConsumableArray(args).concat([options]));\n\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    var enclose = utils.encloseBrace(node);\n    var queue = node.queue;\n    var block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (var i = 0; i < node.nodes.length; i++) {\n      var child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;","map":{"version":3,"sources":["C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/braces/lib/expand.js"],"names":["fill","require","stringify","utils","append","queue","stash","enclose","result","concat","length","flatten","map","ele","item","Array","isArray","value","push","expand","ast","options","rangeLimit","walk","node","parent","p","q","type","invalid","dollar","pop","nodes","ranges","args","reduce","exceedsLimit","step","RangeError","range","encloseBrace","block","i","child","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst fill = require('fill-range');\r\nconst stringify = require('./stringify');\r\nconst utils = require('./utils');\r\n\r\nconst append = (queue = '', stash = '', enclose = false) => {\r\n  let result = [];\r\n\r\n  queue = [].concat(queue);\r\n  stash = [].concat(stash);\r\n\r\n  if (!stash.length) return queue;\r\n  if (!queue.length) {\r\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\r\n  }\r\n\r\n  for (let item of queue) {\r\n    if (Array.isArray(item)) {\r\n      for (let value of item) {\r\n        result.push(append(value, stash, enclose));\r\n      }\r\n    } else {\r\n      for (let ele of stash) {\r\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\r\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\r\n      }\r\n    }\r\n  }\r\n  return utils.flatten(result);\r\n};\r\n\r\nconst expand = (ast, options = {}) => {\r\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\r\n\r\n  let walk = (node, parent = {}) => {\r\n    node.queue = [];\r\n\r\n    let p = parent;\r\n    let q = parent.queue;\r\n\r\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\r\n      p = p.parent;\r\n      q = p.queue;\r\n    }\r\n\r\n    if (node.invalid || node.dollar) {\r\n      q.push(append(q.pop(), stringify(node, options)));\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\r\n      q.push(append(q.pop(), ['{}']));\r\n      return;\r\n    }\r\n\r\n    if (node.nodes && node.ranges > 0) {\r\n      let args = utils.reduce(node.nodes);\r\n\r\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\r\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\r\n      }\r\n\r\n      let range = fill(...args, options);\r\n      if (range.length === 0) {\r\n        range = stringify(node, options);\r\n      }\r\n\r\n      q.push(append(q.pop(), range));\r\n      node.nodes = [];\r\n      return;\r\n    }\r\n\r\n    let enclose = utils.encloseBrace(node);\r\n    let queue = node.queue;\r\n    let block = node;\r\n\r\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\r\n      block = block.parent;\r\n      queue = block.queue;\r\n    }\r\n\r\n    for (let i = 0; i < node.nodes.length; i++) {\r\n      let child = node.nodes[i];\r\n\r\n      if (child.type === 'comma' && node.type === 'brace') {\r\n        if (i === 1) queue.push('');\r\n        queue.push('');\r\n        continue;\r\n      }\r\n\r\n      if (child.type === 'close') {\r\n        q.push(append(q.pop(), queue, enclose));\r\n        continue;\r\n      }\r\n\r\n      if (child.value && child.type !== 'open') {\r\n        queue.push(append(queue.pop(), child.value));\r\n        continue;\r\n      }\r\n\r\n      if (child.nodes) {\r\n        walk(child, node);\r\n      }\r\n    }\r\n\r\n    return queue;\r\n  };\r\n\r\n  return utils.flatten(walk(ast));\r\n};\r\n\r\nmodule.exports = expand;\r\n"]},"metadata":{},"sourceType":"script"}