{"ast":null,"code":"'use strict';\n\nvar _typeof = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _objectSpread = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nrequire(\"core-js/modules/es.number.parse-int.js\");\n\nrequire(\"core-js/modules/es.number.constructor.js\");\n\nrequire(\"core-js/modules/es.string.trim.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.string.starts-with.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nvar fs = require('fs');\n\nvar _require = require('stream'),\n    Readable = _require.Readable;\n\nvar sysPath = require('path');\n\nvar _require2 = require('util'),\n    promisify = _require2.promisify;\n\nvar picomatch = require('picomatch');\n\nvar readdir = promisify(fs.readdir);\nvar stat = promisify(fs.stat);\nvar lstat = promisify(fs.lstat);\nvar realpath = promisify(fs.realpath);\n/**\r\n * @typedef {Object} EntryInfo\r\n * @property {String} path\r\n * @property {String} fullPath\r\n * @property {fs.Stats=} stats\r\n * @property {fs.Dirent=} dirent\r\n * @property {String} basename\r\n */\n\nvar BANG = '!';\nvar RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nvar NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nvar FILE_TYPE = 'files';\nvar DIR_TYPE = 'directories';\nvar FILE_DIR_TYPE = 'files_directories';\nvar EVERYTHING_TYPE = 'all';\nvar ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nvar isNormalFlowError = function isNormalFlowError(error) {\n  return NORMAL_FLOW_ERRORS.has(error.code);\n};\n\nvar _process$versions$nod = process.versions.node.split('.').slice(0, 2).map(function (n) {\n  return Number.parseInt(n, 10);\n}),\n    _process$versions$nod2 = _slicedToArray(_process$versions$nod, 2),\n    maj = _process$versions$nod2[0],\n    min = _process$versions$nod2[1];\n\nvar wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\n\nvar normalizeFilter = function normalizeFilter(filter) {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    var glob = picomatch(filter.trim());\n    return function (entry) {\n      return glob(entry.basename);\n    };\n  }\n\n  if (Array.isArray(filter)) {\n    var positive = [];\n    var negative = [];\n\n    var _iterator = _createForOfIteratorHelper(filter),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        var trimmed = item.trim();\n\n        if (trimmed.charAt(0) === BANG) {\n          negative.push(picomatch(trimmed.slice(1)));\n        } else {\n          positive.push(picomatch(trimmed));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return function (entry) {\n          return positive.some(function (f) {\n            return f(entry.basename);\n          }) && !negative.some(function (f) {\n            return f(entry.basename);\n          });\n        };\n      }\n\n      return function (entry) {\n        return !negative.some(function (f) {\n          return f(entry.basename);\n        });\n      };\n    }\n\n    return function (entry) {\n      return positive.some(function (f) {\n        return f(entry.basename);\n      });\n    };\n  }\n};\n\nvar ReaddirpStream = /*#__PURE__*/function (_Readable) {\n  _inherits(ReaddirpStream, _Readable);\n\n  var _super = _createSuper(ReaddirpStream);\n\n  function ReaddirpStream() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ReaddirpStream);\n\n    _this = _super.call(this, {\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n\n    var opts = _objectSpread(_objectSpread({}, ReaddirpStream.defaultOptions), options);\n\n    var root = opts.root,\n        type = opts.type;\n    _this._fileFilter = normalizeFilter(opts.fileFilter);\n    _this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    var statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (wantBigintFsStats) {\n      _this._stat = function (path) {\n        return statMethod(path, {\n          bigint: true\n        });\n      };\n    } else {\n      _this._stat = statMethod;\n    }\n\n    _this._maxDepth = opts.depth;\n    _this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    _this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    _this._wantsEverything = type === EVERYTHING_TYPE;\n    _this._root = sysPath.resolve(root);\n    _this._isDirent = 'Dirent' in fs && !opts.alwaysStat;\n    _this._statsProp = _this._isDirent ? 'dirent' : 'stats';\n    _this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: _this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    _this.parents = [_this._exploreDir(root, 1)];\n    _this.reading = false;\n    _this.parent = undefined;\n    return _this;\n  }\n\n  _createClass(ReaddirpStream, [{\n    key: \"_read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(batch) {\n        var _this2 = this;\n\n        var _loop, _ret;\n\n        return regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.reading) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                this.reading = true;\n                _context2.prev = 3;\n                _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {\n                  var _ref, path, depth, _ref$files, files, slice, _iterator2, _step2, entry, entryType, parent;\n\n                  return regeneratorRuntime.wrap(function _loop$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _ref = _this2.parent || {}, path = _ref.path, depth = _ref.depth, _ref$files = _ref.files, files = _ref$files === void 0 ? [] : _ref$files;\n\n                          if (!(files.length > 0)) {\n                            _context.next = 30;\n                            break;\n                          }\n\n                          slice = files.splice(0, batch).map(function (dirent) {\n                            return _this2._formatEntry(dirent, path);\n                          });\n                          _context.t0 = _createForOfIteratorHelper;\n                          _context.next = 6;\n                          return Promise.all(slice);\n\n                        case 6:\n                          _context.t1 = _context.sent;\n                          _iterator2 = (0, _context.t0)(_context.t1);\n                          _context.prev = 8;\n\n                          _iterator2.s();\n\n                        case 10:\n                          if ((_step2 = _iterator2.n()).done) {\n                            _context.next = 20;\n                            break;\n                          }\n\n                          entry = _step2.value;\n\n                          if (!_this2.destroyed) {\n                            _context.next = 14;\n                            break;\n                          }\n\n                          return _context.abrupt(\"return\", {\n                            v: void 0\n                          });\n\n                        case 14:\n                          _context.next = 16;\n                          return _this2._getEntryType(entry);\n\n                        case 16:\n                          entryType = _context.sent;\n\n                          if (entryType === 'directory' && _this2._directoryFilter(entry)) {\n                            if (depth <= _this2._maxDepth) {\n                              _this2.parents.push(_this2._exploreDir(entry.fullPath, depth + 1));\n                            }\n\n                            if (_this2._wantsDir) {\n                              _this2.push(entry);\n\n                              batch--;\n                            }\n                          } else if ((entryType === 'file' || _this2._includeAsFile(entry)) && _this2._fileFilter(entry)) {\n                            if (_this2._wantsFile) {\n                              _this2.push(entry);\n\n                              batch--;\n                            }\n                          }\n\n                        case 18:\n                          _context.next = 10;\n                          break;\n\n                        case 20:\n                          _context.next = 25;\n                          break;\n\n                        case 22:\n                          _context.prev = 22;\n                          _context.t2 = _context[\"catch\"](8);\n\n                          _iterator2.e(_context.t2);\n\n                        case 25:\n                          _context.prev = 25;\n\n                          _iterator2.f();\n\n                          return _context.finish(25);\n\n                        case 28:\n                          _context.next = 39;\n                          break;\n\n                        case 30:\n                          parent = _this2.parents.pop();\n\n                          if (parent) {\n                            _context.next = 34;\n                            break;\n                          }\n\n                          _this2.push(null);\n\n                          return _context.abrupt(\"return\", \"break\");\n\n                        case 34:\n                          _context.next = 36;\n                          return parent;\n\n                        case 36:\n                          _this2.parent = _context.sent;\n\n                          if (!_this2.destroyed) {\n                            _context.next = 39;\n                            break;\n                          }\n\n                          return _context.abrupt(\"return\", {\n                            v: void 0\n                          });\n\n                        case 39:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _loop, null, [[8, 22, 25, 28]]);\n                });\n\n              case 5:\n                if (!(!this.destroyed && batch > 0)) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                return _context2.delegateYield(_loop(), \"t0\", 7);\n\n              case 7:\n                _ret = _context2.t0;\n\n                if (!(_ret === \"break\")) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"break\", 14);\n\n              case 10:\n                if (!(_typeof(_ret) === \"object\")) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _ret.v);\n\n              case 12:\n                _context2.next = 5;\n                break;\n\n              case 14:\n                _context2.next = 19;\n                break;\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t1 = _context2[\"catch\"](3);\n                this.destroy(_context2.t1);\n\n              case 19:\n                _context2.prev = 19;\n                this.reading = false;\n                return _context2.finish(19);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee, this, [[3, 16, 19, 22]]);\n      }));\n\n      function _read(_x) {\n        return _read2.apply(this, arguments);\n      }\n\n      return _read;\n    }()\n  }, {\n    key: \"_exploreDir\",\n    value: function () {\n      var _exploreDir2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path, depth) {\n        var files;\n        return regeneratorRuntime.wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return readdir(path, this._rdOptions);\n\n              case 3:\n                files = _context3.sent;\n                _context3.next = 9;\n                break;\n\n              case 6:\n                _context3.prev = 6;\n                _context3.t0 = _context3[\"catch\"](0);\n\n                this._onError(_context3.t0);\n\n              case 9:\n                return _context3.abrupt(\"return\", {\n                  files: files,\n                  depth: depth,\n                  path: path\n                });\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2, this, [[0, 6]]);\n      }));\n\n      function _exploreDir(_x2, _x3) {\n        return _exploreDir2.apply(this, arguments);\n      }\n\n      return _exploreDir;\n    }()\n  }, {\n    key: \"_formatEntry\",\n    value: function () {\n      var _formatEntry2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(dirent, path) {\n        var entry, basename, fullPath;\n        return regeneratorRuntime.wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                basename = this._isDirent ? dirent.name : dirent;\n                fullPath = sysPath.resolve(sysPath.join(path, basename));\n                entry = {\n                  path: sysPath.relative(this._root, fullPath),\n                  fullPath: fullPath,\n                  basename: basename\n                };\n\n                if (!this._isDirent) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                _context4.t0 = dirent;\n                _context4.next = 11;\n                break;\n\n              case 8:\n                _context4.next = 10;\n                return this._stat(fullPath);\n\n              case 10:\n                _context4.t0 = _context4.sent;\n\n              case 11:\n                entry[this._statsProp] = _context4.t0;\n                _context4.next = 17;\n                break;\n\n              case 14:\n                _context4.prev = 14;\n                _context4.t1 = _context4[\"catch\"](0);\n\n                this._onError(_context4.t1);\n\n              case 17:\n                return _context4.abrupt(\"return\", entry);\n\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3, this, [[0, 14]]);\n      }));\n\n      function _formatEntry(_x4, _x5) {\n        return _formatEntry2.apply(this, arguments);\n      }\n\n      return _formatEntry;\n    }()\n  }, {\n    key: \"_onError\",\n    value: function _onError(err) {\n      if (isNormalFlowError(err) && !this.destroyed) {\n        this.emit('warn', err);\n      } else {\n        this.destroy(err);\n      }\n    }\n  }, {\n    key: \"_getEntryType\",\n    value: function () {\n      var _getEntryType2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(entry) {\n        var stats, full, entryRealPath, entryRealPathStats, len, recursiveError;\n        return regeneratorRuntime.wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                // entry may be undefined, because a warning or an error were emitted\n                // and the statsProp is undefined\n                stats = entry && entry[this._statsProp];\n\n                if (stats) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 3:\n                if (!stats.isFile()) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", 'file');\n\n              case 5:\n                if (!stats.isDirectory()) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", 'directory');\n\n              case 7:\n                if (!(stats && stats.isSymbolicLink())) {\n                  _context5.next = 30;\n                  break;\n                }\n\n                full = entry.fullPath;\n                _context5.prev = 9;\n                _context5.next = 12;\n                return realpath(full);\n\n              case 12:\n                entryRealPath = _context5.sent;\n                _context5.next = 15;\n                return lstat(entryRealPath);\n\n              case 15:\n                entryRealPathStats = _context5.sent;\n\n                if (!entryRealPathStats.isFile()) {\n                  _context5.next = 18;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", 'file');\n\n              case 18:\n                if (!entryRealPathStats.isDirectory()) {\n                  _context5.next = 25;\n                  break;\n                }\n\n                len = entryRealPath.length;\n\n                if (!(full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep)) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                recursiveError = new Error(\"Circular symlink detected: \\\"\".concat(full, \"\\\" points to \\\"\").concat(entryRealPath, \"\\\"\"));\n                recursiveError.code = RECURSIVE_ERROR_CODE;\n                return _context5.abrupt(\"return\", this._onError(recursiveError));\n\n              case 24:\n                return _context5.abrupt(\"return\", 'directory');\n\n              case 25:\n                _context5.next = 30;\n                break;\n\n              case 27:\n                _context5.prev = 27;\n                _context5.t0 = _context5[\"catch\"](9);\n\n                this._onError(_context5.t0);\n\n              case 30:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this, [[9, 27]]);\n      }));\n\n      function _getEntryType(_x6) {\n        return _getEntryType2.apply(this, arguments);\n      }\n\n      return _getEntryType;\n    }()\n  }, {\n    key: \"_includeAsFile\",\n    value: function _includeAsFile(entry) {\n      var stats = entry && entry[this._statsProp];\n      return stats && this._wantsEverything && !stats.isDirectory();\n    }\n  }], [{\n    key: \"defaultOptions\",\n    get: function get() {\n      return {\n        root: '.',\n\n        /* eslint-disable no-unused-vars */\n        fileFilter: function fileFilter(path) {\n          return true;\n        },\n        directoryFilter: function directoryFilter(path) {\n          return true;\n        },\n\n        /* eslint-enable no-unused-vars */\n        type: FILE_TYPE,\n        lstat: false,\n        depth: 2147483648,\n        alwaysStat: false\n      };\n    }\n  }]);\n\n  return ReaddirpStream;\n}(Readable);\n/**\r\n * @typedef {Object} ReaddirpArguments\r\n * @property {Function=} fileFilter\r\n * @property {Function=} directoryFilter\r\n * @property {String=} type\r\n * @property {Number=} depth\r\n * @property {String=} root\r\n * @property {Boolean=} lstat\r\n * @property {Boolean=} bigint\r\n */\n\n/**\r\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\r\n * @param {String} root Root directory\r\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\r\n */\n\n\nvar readdirp = function readdirp(root) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(\"readdirp: Invalid type passed. Use one of \".concat(ALL_TYPES.join(', ')));\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nvar readdirpPromise = function readdirpPromise(root) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(function (resolve, reject) {\n    var files = [];\n    readdirp(root, options).on('data', function (entry) {\n      return files.push(entry);\n    }).on('end', function () {\n      return resolve(files);\n    }).on('error', function (error) {\n      return reject(error);\n    });\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nmodule.exports = readdirp;","map":{"version":3,"sources":["C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/readdirp/index.js"],"names":["fs","require","Readable","sysPath","promisify","picomatch","readdir","stat","lstat","realpath","BANG","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","process","versions","node","split","slice","map","n","Number","parseInt","maj","min","wantBigintFsStats","platform","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","length","some","f","ReaddirpStream","options","objectMode","autoDestroy","highWaterMark","opts","defaultOptions","root","type","_fileFilter","fileFilter","_directoryFilter","directoryFilter","statMethod","_stat","path","bigint","_maxDepth","depth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","resolve","_isDirent","alwaysStat","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","batch","files","splice","dirent","_formatEntry","Promise","all","destroyed","_getEntryType","entryType","fullPath","_includeAsFile","pop","destroy","_onError","name","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","recursiveError","Error","readdirp","TypeError","readdirpPromise","reject","on","promise","default","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst { Readable } = require('stream');\r\nconst sysPath = require('path');\r\nconst { promisify } = require('util');\r\nconst picomatch = require('picomatch');\r\n\r\nconst readdir = promisify(fs.readdir);\r\nconst stat = promisify(fs.stat);\r\nconst lstat = promisify(fs.lstat);\r\nconst realpath = promisify(fs.realpath);\r\n\r\n/**\r\n * @typedef {Object} EntryInfo\r\n * @property {String} path\r\n * @property {String} fullPath\r\n * @property {fs.Stats=} stats\r\n * @property {fs.Dirent=} dirent\r\n * @property {String} basename\r\n */\r\n\r\nconst BANG = '!';\r\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\r\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\r\nconst FILE_TYPE = 'files';\r\nconst DIR_TYPE = 'directories';\r\nconst FILE_DIR_TYPE = 'files_directories';\r\nconst EVERYTHING_TYPE = 'all';\r\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\r\n\r\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\r\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\r\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\r\n\r\nconst normalizeFilter = filter => {\r\n  if (filter === undefined) return;\r\n  if (typeof filter === 'function') return filter;\r\n\r\n  if (typeof filter === 'string') {\r\n    const glob = picomatch(filter.trim());\r\n    return entry => glob(entry.basename);\r\n  }\r\n\r\n  if (Array.isArray(filter)) {\r\n    const positive = [];\r\n    const negative = [];\r\n    for (const item of filter) {\r\n      const trimmed = item.trim();\r\n      if (trimmed.charAt(0) === BANG) {\r\n        negative.push(picomatch(trimmed.slice(1)));\r\n      } else {\r\n        positive.push(picomatch(trimmed));\r\n      }\r\n    }\r\n\r\n    if (negative.length > 0) {\r\n      if (positive.length > 0) {\r\n        return entry =>\r\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\r\n      }\r\n      return entry => !negative.some(f => f(entry.basename));\r\n    }\r\n    return entry => positive.some(f => f(entry.basename));\r\n  }\r\n};\r\n\r\nclass ReaddirpStream extends Readable {\r\n  static get defaultOptions() {\r\n    return {\r\n      root: '.',\r\n      /* eslint-disable no-unused-vars */\r\n      fileFilter: (path) => true,\r\n      directoryFilter: (path) => true,\r\n      /* eslint-enable no-unused-vars */\r\n      type: FILE_TYPE,\r\n      lstat: false,\r\n      depth: 2147483648,\r\n      alwaysStat: false\r\n    };\r\n  }\r\n\r\n  constructor(options = {}) {\r\n    super({\r\n      objectMode: true,\r\n      autoDestroy: true,\r\n      highWaterMark: options.highWaterMark || 4096\r\n    });\r\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\r\n    const { root, type } = opts;\r\n\r\n    this._fileFilter = normalizeFilter(opts.fileFilter);\r\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\r\n\r\n    const statMethod = opts.lstat ? lstat : stat;\r\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\r\n    if (wantBigintFsStats) {\r\n      this._stat = path => statMethod(path, { bigint: true });\r\n    } else {\r\n      this._stat = statMethod;\r\n    }\r\n\r\n    this._maxDepth = opts.depth;\r\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\r\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\r\n    this._wantsEverything = type === EVERYTHING_TYPE;\r\n    this._root = sysPath.resolve(root);\r\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\r\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\r\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\r\n\r\n    // Launch stream with one parent, the root dir.\r\n    this.parents = [this._exploreDir(root, 1)];\r\n    this.reading = false;\r\n    this.parent = undefined;\r\n  }\r\n\r\n  async _read(batch) {\r\n    if (this.reading) return;\r\n    this.reading = true;\r\n\r\n    try {\r\n      while (!this.destroyed && batch > 0) {\r\n        const { path, depth, files = [] } = this.parent || {};\r\n\r\n        if (files.length > 0) {\r\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\r\n          for (const entry of await Promise.all(slice)) {\r\n            if (this.destroyed) return;\r\n\r\n            const entryType = await this._getEntryType(entry);\r\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\r\n              if (depth <= this._maxDepth) {\r\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\r\n              }\r\n\r\n              if (this._wantsDir) {\r\n                this.push(entry);\r\n                batch--;\r\n              }\r\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\r\n              if (this._wantsFile) {\r\n                this.push(entry);\r\n                batch--;\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          const parent = this.parents.pop();\r\n          if (!parent) {\r\n            this.push(null);\r\n            break;\r\n          }\r\n          this.parent = await parent;\r\n          if (this.destroyed) return;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.destroy(error);\r\n    } finally {\r\n      this.reading = false;\r\n    }\r\n  }\r\n\r\n  async _exploreDir(path, depth) {\r\n    let files;\r\n    try {\r\n      files = await readdir(path, this._rdOptions);\r\n    } catch (error) {\r\n      this._onError(error);\r\n    }\r\n    return { files, depth, path };\r\n  }\r\n\r\n  async _formatEntry(dirent, path) {\r\n    let entry;\r\n    try {\r\n      const basename = this._isDirent ? dirent.name : dirent;\r\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\r\n      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\r\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\r\n    } catch (err) {\r\n      this._onError(err);\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  _onError(err) {\r\n    if (isNormalFlowError(err) && !this.destroyed) {\r\n      this.emit('warn', err);\r\n    } else {\r\n      this.destroy(err);\r\n    }\r\n  }\r\n\r\n  async _getEntryType(entry) {\r\n    // entry may be undefined, because a warning or an error were emitted\r\n    // and the statsProp is undefined\r\n    const stats = entry && entry[this._statsProp];\r\n    if (!stats) {\r\n      return;\r\n    }\r\n    if (stats.isFile()) {\r\n      return 'file';\r\n    }\r\n    if (stats.isDirectory()) {\r\n      return 'directory';\r\n    }\r\n    if (stats && stats.isSymbolicLink()) {\r\n      const full = entry.fullPath;\r\n      try {\r\n        const entryRealPath = await realpath(full);\r\n        const entryRealPathStats = await lstat(entryRealPath);\r\n        if (entryRealPathStats.isFile()) {\r\n          return 'file';\r\n        }\r\n        if (entryRealPathStats.isDirectory()) {\r\n          const len = entryRealPath.length;\r\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\r\n            const recursiveError = new Error(\r\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\r\n            );\r\n            recursiveError.code = RECURSIVE_ERROR_CODE;\r\n            return this._onError(recursiveError);\r\n          }\r\n          return 'directory';\r\n        }\r\n      } catch (error) {\r\n        this._onError(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  _includeAsFile(entry) {\r\n    const stats = entry && entry[this._statsProp];\r\n\r\n    return stats && this._wantsEverything && !stats.isDirectory();\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} ReaddirpArguments\r\n * @property {Function=} fileFilter\r\n * @property {Function=} directoryFilter\r\n * @property {String=} type\r\n * @property {Number=} depth\r\n * @property {String=} root\r\n * @property {Boolean=} lstat\r\n * @property {Boolean=} bigint\r\n */\r\n\r\n/**\r\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\r\n * @param {String} root Root directory\r\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\r\n */\r\nconst readdirp = (root, options = {}) => {\r\n  let type = options.entryType || options.type;\r\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\r\n  if (type) options.type = type;\r\n  if (!root) {\r\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\r\n  } else if (typeof root !== 'string') {\r\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\r\n  } else if (type && !ALL_TYPES.includes(type)) {\r\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\r\n  }\r\n\r\n  options.root = root;\r\n  return new ReaddirpStream(options);\r\n};\r\n\r\nconst readdirpPromise = (root, options = {}) => {\r\n  return new Promise((resolve, reject) => {\r\n    const files = [];\r\n    readdirp(root, options)\r\n      .on('data', entry => files.push(entry))\r\n      .on('end', () => resolve(files))\r\n      .on('error', error => reject(error));\r\n  });\r\n};\r\n\r\nreaddirp.promise = readdirpPromise;\r\nreaddirp.ReaddirpStream = ReaddirpStream;\r\nreaddirp.default = readdirp;\r\n\r\nmodule.exports = readdirp;\r\n"]},"metadata":{},"sourceType":"script"}