{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nrequire(\"regenerator-runtime/runtime.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.object.freeze.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar _require = require('util'),\n    promisify = _require.promisify;\n\nvar isBinaryPath = require('is-binary-path');\n\nvar _require2 = require('./constants'),\n    isWindows = _require2.isWindows,\n    isLinux = _require2.isLinux,\n    EMPTY_FN = _require2.EMPTY_FN,\n    EMPTY_STR = _require2.EMPTY_STR,\n    KEY_LISTENERS = _require2.KEY_LISTENERS,\n    KEY_ERR = _require2.KEY_ERR,\n    KEY_RAW = _require2.KEY_RAW,\n    HANDLER_KEYS = _require2.HANDLER_KEYS,\n    EV_CHANGE = _require2.EV_CHANGE,\n    EV_ADD = _require2.EV_ADD,\n    EV_ADD_DIR = _require2.EV_ADD_DIR,\n    EV_ERROR = _require2.EV_ERROR,\n    STR_DATA = _require2.STR_DATA,\n    STR_END = _require2.STR_END,\n    BRACE_START = _require2.BRACE_START,\n    STAR = _require2.STAR;\n\nvar THROTTLE_MODE_WATCH = 'watch';\nvar open = promisify(fs.open);\nvar stat = promisify(fs.stat);\nvar lstat = promisify(fs.lstat);\nvar close = promisify(fs.close);\nvar fsrealpath = promisify(fs.realpath);\nvar statMethods = {\n  lstat: lstat,\n  stat: stat\n}; // TODO: emit errors properly. Example: EMFILE on Macos.\n\nvar foreach = function foreach(val, fn) {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nvar addAndConvert = function addAndConvert(main, prop, item) {\n  var container = main[prop];\n\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n\n  container.add(item);\n};\n\nvar clearItem = function clearItem(cont) {\n  return function (key) {\n    var set = cont[key];\n\n    if (set instanceof Set) {\n      set.clear();\n    } else {\n      delete cont[key];\n    }\n  };\n};\n\nvar delFromSet = function delFromSet(main, prop, item) {\n  var container = main[prop];\n\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nvar isEmptySet = function isEmptySet(val) {\n  return val instanceof Set ? val.size === 0 : !val;\n};\n/**\r\n * @typedef {String} Path\r\n */\n// fs_watch helpers\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\r\n * @typedef {Object} FsWatchContainer\r\n * @property {Set} listeners\r\n * @property {Set} errHandlers\r\n * @property {Set} rawEmitters\r\n * @property {fs.FSWatcher=} watcher\r\n * @property {Boolean=} watcherUnusable\r\n */\n\n/**\r\n * @type {Map<String,FsWatchContainer>}\r\n */\n\n\nvar FsWatchInstances = new Map();\n/**\r\n * Instantiates the fs_watch interface\r\n * @param {String} path to be watched\r\n * @param {Object} options to be passed to fs_watch\r\n * @param {Function} listener main event handler\r\n * @param {Function} errHandler emits info about errors\r\n * @param {Function} emitRaw emits raw event data\r\n * @returns {fs.FSWatcher} new fsevents instance\r\n */\n\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  var handleEvent = function handleEvent(rawEvent, evPath) {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    }); // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));\n    }\n  };\n\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n/**\r\n * Helper for passing fs_watch event data to a collection of listeners\r\n * @param {Path} fullPath absolute path bound to fs_watch instance\r\n * @param {String} type listener type\r\n * @param {*=} val1 arguments to be passed to listeners\r\n * @param {*=} val2\r\n * @param {*=} val3\r\n */\n\n\nvar fsWatchBroadcast = function fsWatchBroadcast(fullPath, type, val1, val2, val3) {\n  var cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], function (listener) {\n    listener(val1, val2, val3);\n  });\n};\n/**\r\n * Instantiates the fs_watch interface or binds listeners\r\n * to an existing one covering the same file system entry\r\n * @param {String} path\r\n * @param {String} fullPath absolute path\r\n * @param {Object} options to be passed to fs_watch\r\n * @param {Object} handlers container for event listener functions\r\n */\n\n\nvar setFsWatchListener = function setFsWatchListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener,\n      errHandler = handlers.errHandler,\n      rawEmitter = handlers.rawEmitter;\n  var cont = FsWatchInstances.get(fullPath);\n  /** @type {fs.FSWatcher=} */\n\n  var watcher;\n\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(error) {\n        var broadcastErr, fd;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n                cont.watcherUnusable = true; // documented since Node 10.4.1\n                // Workaround for https://github.com/joyent/node/issues/4337\n\n                if (!(isWindows && error.code === 'EPERM')) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.prev = 3;\n                _context.next = 6;\n                return open(path, 'r');\n\n              case 6:\n                fd = _context.sent;\n                _context.next = 9;\n                return close(fd);\n\n              case 9:\n                broadcastErr(error);\n                _context.next = 14;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](3);\n\n              case 14:\n                _context.next = 17;\n                break;\n\n              case 16:\n                broadcastErr(error);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3, 12]]);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher: watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n\n\n  return function () {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close(); // }\n\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n}; // fs_watchFile helpers\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nvar FsWatchFileInstances = new Map();\n/**\r\n * Instantiates the fs_watchFile interface or binds listeners\r\n * to an existing one covering the same file system entry\r\n * @param {String} path to be watched\r\n * @param {String} fullPath absolute path\r\n * @param {Object} options options to be passed to fs_watchFile\r\n * @param {Object} handlers container for event listener functions\r\n * @returns {Function} closer\r\n */\n\nvar setFsWatchFileListener = function setFsWatchFileListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener,\n      rawEmitter = handlers.rawEmitter;\n  var cont = FsWatchFileInstances.get(fullPath);\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n\n  var listeners = new Set();\n  var rawEmitters = new Set();\n  var copts = cont && cont.options;\n\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options: options,\n      watcher: fs.watchFile(fullPath, options, function (curr, prev) {\n        foreach(cont.rawEmitters, function (rawEmitter) {\n          rawEmitter(EV_CHANGE, fullPath, {\n            curr: curr,\n            prev: prev\n          });\n        });\n        var currmtime = curr.mtimeMs;\n\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, function (listener) {\n            return listener(path, curr);\n          });\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n\n\n  return function () {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n/**\r\n * @mixin\r\n */\n\n\nvar NodeFsHandler = /*#__PURE__*/function () {\n  /**\r\n   * @param {import(\"../index\").FSWatcher} fsW\r\n   */\n  function NodeFsHandler(fsW) {\n    _classCallCheck(this, NodeFsHandler);\n\n    this.fsw = fsW;\n\n    this._boundHandleError = function (error) {\n      return fsW._handleError(error);\n    };\n  }\n  /**\r\n   * Watch file for changes with fs_watchFile or fs_watch.\r\n   * @param {String} path to file or dir\r\n   * @param {Function} listener on fs change\r\n   * @returns {Function} closer for the watcher instance\r\n   */\n\n\n  _createClass(NodeFsHandler, [{\n    key: \"_watchWithNodeFs\",\n    value: function _watchWithNodeFs(path, listener) {\n      var opts = this.fsw.options;\n      var directory = sysPath.dirname(path);\n      var basename = sysPath.basename(path);\n\n      var parent = this.fsw._getWatchedDir(directory);\n\n      parent.add(basename);\n      var absolutePath = sysPath.resolve(path);\n      var options = {\n        persistent: opts.persistent\n      };\n      if (!listener) listener = EMPTY_FN;\n      var closer;\n\n      if (opts.usePolling) {\n        options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n        closer = setFsWatchFileListener(path, absolutePath, options, {\n          listener: listener,\n          rawEmitter: this.fsw._emitRaw\n        });\n      } else {\n        closer = setFsWatchListener(path, absolutePath, options, {\n          listener: listener,\n          errHandler: this._boundHandleError,\n          rawEmitter: this.fsw._emitRaw\n        });\n      }\n\n      return closer;\n    }\n    /**\r\n     * Watch a file and emit add event if warranted.\r\n     * @param {Path} file Path\r\n     * @param {fs.Stats} stats result of fs_stat\r\n     * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n     * @returns {Function} closer for the watcher instance\r\n     */\n\n  }, {\n    key: \"_handleFile\",\n    value: function _handleFile(file, stats, initialAdd) {\n      var _this = this;\n\n      if (this.fsw.closed) {\n        return;\n      }\n\n      var dirname = sysPath.dirname(file);\n      var basename = sysPath.basename(file);\n\n      var parent = this.fsw._getWatchedDir(dirname); // stats is always present\n\n\n      var prevStats = stats; // if the file is already being watched, do nothing\n\n      if (parent.has(basename)) return;\n\n      var listener = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path, newStats) {\n          var _newStats, at, mt, _at, _mt;\n\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (_this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 2:\n                  if (!(!newStats || newStats.mtimeMs === 0)) {\n                    _context2.next = 20;\n                    break;\n                  }\n\n                  _context2.prev = 3;\n                  _context2.next = 6;\n                  return stat(file);\n\n                case 6:\n                  _newStats = _context2.sent;\n\n                  if (!_this.fsw.closed) {\n                    _context2.next = 9;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 9:\n                  // Check that change event was not fired because of changed only accessTime.\n                  at = _newStats.atimeMs;\n                  mt = _newStats.mtimeMs;\n\n                  if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n                    _this.fsw._emit(EV_CHANGE, file, _newStats);\n                  }\n\n                  if (isLinux && prevStats.ino !== _newStats.ino) {\n                    _this.fsw._closeFile(path);\n\n                    prevStats = _newStats;\n\n                    _this.fsw._addPathCloser(path, _this._watchWithNodeFs(file, listener));\n                  } else {\n                    prevStats = _newStats;\n                  }\n\n                  _context2.next = 18;\n                  break;\n\n                case 15:\n                  _context2.prev = 15;\n                  _context2.t0 = _context2[\"catch\"](3);\n\n                  // Fix issues where mtime is null but file is still present\n                  _this.fsw._remove(dirname, basename);\n\n                case 18:\n                  _context2.next = 21;\n                  break;\n\n                case 20:\n                  if (parent.has(basename)) {\n                    // Check that change event was not fired because of changed only accessTime.\n                    _at = newStats.atimeMs;\n                    _mt = newStats.mtimeMs;\n\n                    if (!_at || _at <= _mt || _mt !== prevStats.mtimeMs) {\n                      _this.fsw._emit(EV_CHANGE, file, newStats);\n                    }\n\n                    prevStats = newStats;\n                  }\n\n                case 21:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[3, 15]]);\n        }));\n\n        return function listener(_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }(); // kick off the watcher\n\n\n      var closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to\n\n\n      if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n        if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n\n        this.fsw._emit(EV_ADD, file, stats);\n      }\n\n      return closer;\n    }\n    /**\r\n     * Handle symlinks encountered while reading a dir.\r\n     * @param {Object} entry returned by readdirp\r\n     * @param {String} directory path of dir being read\r\n     * @param {String} path of this item\r\n     * @param {String} item basename of this item\r\n     * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\r\n     */\n\n  }, {\n    key: \"_handleSymlink\",\n    value: function () {\n      var _handleSymlink2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(entry, directory, path, item) {\n        var full, dir, linkPath;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.fsw.closed) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                full = entry.fullPath;\n                dir = this.fsw._getWatchedDir(directory);\n\n                if (this.fsw.options.followSymlinks) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                // watch symlink directly (don't follow) and detect changes\n                this.fsw._incrReadyCount();\n\n                _context3.prev = 6;\n                _context3.next = 9;\n                return fsrealpath(path);\n\n              case 9:\n                linkPath = _context3.sent;\n                _context3.next = 16;\n                break;\n\n              case 12:\n                _context3.prev = 12;\n                _context3.t0 = _context3[\"catch\"](6);\n\n                this.fsw._emitReady();\n\n                return _context3.abrupt(\"return\", true);\n\n              case 16:\n                if (!this.fsw.closed) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 18:\n                if (dir.has(item)) {\n                  if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n                    this.fsw._symlinkPaths.set(full, linkPath);\n\n                    this.fsw._emit(EV_CHANGE, path, entry.stats);\n                  }\n                } else {\n                  dir.add(item);\n\n                  this.fsw._symlinkPaths.set(full, linkPath);\n\n                  this.fsw._emit(EV_ADD, path, entry.stats);\n                }\n\n                this.fsw._emitReady();\n\n                return _context3.abrupt(\"return\", true);\n\n              case 21:\n                if (!this.fsw._symlinkPaths.has(full)) {\n                  _context3.next = 23;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", true);\n\n              case 23:\n                this.fsw._symlinkPaths.set(full, true);\n\n              case 24:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[6, 12]]);\n      }));\n\n      function _handleSymlink(_x4, _x5, _x6, _x7) {\n        return _handleSymlink2.apply(this, arguments);\n      }\n\n      return _handleSymlink;\n    }()\n  }, {\n    key: \"_handleRead\",\n    value: function _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n      var _this2 = this;\n\n      // Normalize the directory name on Windows\n      directory = sysPath.join(directory, EMPTY_STR);\n\n      if (!wh.hasGlob) {\n        throttler = this.fsw._throttle('readdir', directory, 1000);\n        if (!throttler) return;\n      }\n\n      var previous = this.fsw._getWatchedDir(wh.path);\n\n      var current = new Set();\n\n      var stream = this.fsw._readdirp(directory, {\n        fileFilter: function fileFilter(entry) {\n          return wh.filterPath(entry);\n        },\n        directoryFilter: function directoryFilter(entry) {\n          return wh.filterDir(entry);\n        },\n        depth: 0\n      }).on(STR_DATA, /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(entry) {\n          var item, path;\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  if (!_this2.fsw.closed) {\n                    _context4.next = 3;\n                    break;\n                  }\n\n                  stream = undefined;\n                  return _context4.abrupt(\"return\");\n\n                case 3:\n                  item = entry.path;\n                  path = sysPath.join(directory, item);\n                  current.add(item);\n                  _context4.t0 = entry.stats.isSymbolicLink();\n\n                  if (!_context4.t0) {\n                    _context4.next = 11;\n                    break;\n                  }\n\n                  _context4.next = 10;\n                  return _this2._handleSymlink(entry, directory, path, item);\n\n                case 10:\n                  _context4.t0 = _context4.sent;\n\n                case 11:\n                  if (!_context4.t0) {\n                    _context4.next = 13;\n                    break;\n                  }\n\n                  return _context4.abrupt(\"return\");\n\n                case 13:\n                  if (!_this2.fsw.closed) {\n                    _context4.next = 16;\n                    break;\n                  }\n\n                  stream = undefined;\n                  return _context4.abrupt(\"return\");\n\n                case 16:\n                  // Files that present in current directory snapshot\n                  // but absent in previous are added to watch list and\n                  // emit `add` event.\n                  if (item === target || !target && !previous.has(item)) {\n                    _this2.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse\n\n\n                    path = sysPath.join(dir, sysPath.relative(dir, path));\n\n                    _this2._addToNodeFs(path, initialAdd, wh, depth + 1);\n                  }\n\n                case 17:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n\n        return function (_x8) {\n          return _ref3.apply(this, arguments);\n        };\n      }()).on(EV_ERROR, this._boundHandleError);\n\n      return new Promise(function (resolve) {\n        return stream.once(STR_END, function () {\n          if (_this2.fsw.closed) {\n            stream = undefined;\n            return;\n          }\n\n          var wasThrottled = throttler ? throttler.clear() : false;\n          resolve(); // Files that absent in current directory snapshot\n          // but present in previous emit `remove` event\n          // and are removed from @watched[directory].\n\n          previous.getChildren().filter(function (item) {\n            return item !== directory && !current.has(item) && ( // in case of intersecting globs;\n            // a path may have been filtered out of this readdir, but\n            // shouldn't be removed because it matches a different glob\n            !wh.hasGlob || wh.filterPath({\n              fullPath: sysPath.resolve(directory, item)\n            }));\n          }).forEach(function (item) {\n            _this2.fsw._remove(directory, item);\n          });\n          stream = undefined; // one more time for any missed in case changes came in extremely quickly\n\n          if (wasThrottled) _this2._handleRead(directory, false, wh, target, dir, depth, throttler);\n        });\n      });\n    }\n    /**\r\n     * Read directory to add / remove files from `@watched` list and re-read it on change.\r\n     * @param {String} dir fs path\r\n     * @param {fs.Stats} stats\r\n     * @param {Boolean} initialAdd\r\n     * @param {Number} depth relative to user-supplied path\r\n     * @param {String} target child path targeted for watch\r\n     * @param {Object} wh Common watch helpers for this path\r\n     * @param {String} realpath\r\n     * @returns {Promise<Function>} closer for the watcher instance.\r\n     */\n\n  }, {\n    key: \"_handleDir\",\n    value: function () {\n      var _handleDir2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(dir, stats, initialAdd, depth, target, wh, realpath) {\n        var _this3 = this;\n\n        var parentDir, tracked, throttler, closer, oDepth;\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n                tracked = parentDir.has(sysPath.basename(dir));\n\n                if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n                  if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n                } // ensure dir is tracked (harmless if redundant)\n\n\n                parentDir.add(sysPath.basename(dir));\n\n                this.fsw._getWatchedDir(dir);\n\n                oDepth = this.fsw.options.depth;\n\n                if (!((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath))) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                if (target) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _context5.next = 10;\n                return this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n\n              case 10:\n                if (!this.fsw.closed) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 12:\n                closer = this._watchWithNodeFs(dir, function (dirPath, stats) {\n                  // if current directory is removed, do nothing\n                  if (stats && stats.mtimeMs === 0) return;\n\n                  _this3._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n                });\n\n              case 13:\n                return _context5.abrupt(\"return\", closer);\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _handleDir(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {\n        return _handleDir2.apply(this, arguments);\n      }\n\n      return _handleDir;\n    }()\n    /**\r\n     * Handle added file, directory, or glob pattern.\r\n     * Delegates call to _handleFile / _handleDir after checks.\r\n     * @param {String} path to file or ir\r\n     * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n     * @param {Object} priorWh depth relative to user-supplied path\r\n     * @param {Number} depth Child path actually targeted for watch\r\n     * @param {String=} target Child path actually targeted for watch\r\n     * @returns {Promise}\r\n     */\n\n  }, {\n    key: \"_addToNodeFs\",\n    value: function () {\n      var _addToNodeFs2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(path, initialAdd, priorWh, depth, target) {\n        var ready, wh, stats, follow, closer, absPath, targetPath, _targetPath, parent;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                ready = this.fsw._emitReady;\n\n                if (!(this.fsw._isIgnored(path) || this.fsw.closed)) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                ready();\n                return _context6.abrupt(\"return\", false);\n\n              case 4:\n                wh = this.fsw._getWatchHelpers(path, depth);\n\n                if (!wh.hasGlob && priorWh) {\n                  wh.hasGlob = priorWh.hasGlob;\n                  wh.globFilter = priorWh.globFilter;\n\n                  wh.filterPath = function (entry) {\n                    return priorWh.filterPath(entry);\n                  };\n\n                  wh.filterDir = function (entry) {\n                    return priorWh.filterDir(entry);\n                  };\n                } // evaluate what is at the path we're being asked to watch\n\n\n                _context6.prev = 6;\n                _context6.next = 9;\n                return statMethods[wh.statMethod](wh.watchPath);\n\n              case 9:\n                stats = _context6.sent;\n\n                if (!this.fsw.closed) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 12:\n                if (!this.fsw._isIgnored(wh.watchPath, stats)) {\n                  _context6.next = 15;\n                  break;\n                }\n\n                ready();\n                return _context6.abrupt(\"return\", false);\n\n              case 15:\n                follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n\n                if (!stats.isDirectory()) {\n                  _context6.next = 36;\n                  break;\n                }\n\n                absPath = sysPath.resolve(path);\n\n                if (!follow) {\n                  _context6.next = 24;\n                  break;\n                }\n\n                _context6.next = 21;\n                return fsrealpath(path);\n\n              case 21:\n                _context6.t0 = _context6.sent;\n                _context6.next = 25;\n                break;\n\n              case 24:\n                _context6.t0 = path;\n\n              case 25:\n                targetPath = _context6.t0;\n\n                if (!this.fsw.closed) {\n                  _context6.next = 28;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 28:\n                _context6.next = 30;\n                return this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n\n              case 30:\n                closer = _context6.sent;\n\n                if (!this.fsw.closed) {\n                  _context6.next = 33;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 33:\n                // preserve this symlink's target path\n                if (absPath !== targetPath && targetPath !== undefined) {\n                  this.fsw._symlinkPaths.set(absPath, targetPath);\n                }\n\n                _context6.next = 59;\n                break;\n\n              case 36:\n                if (!stats.isSymbolicLink()) {\n                  _context6.next = 58;\n                  break;\n                }\n\n                if (!follow) {\n                  _context6.next = 43;\n                  break;\n                }\n\n                _context6.next = 40;\n                return fsrealpath(path);\n\n              case 40:\n                _context6.t1 = _context6.sent;\n                _context6.next = 44;\n                break;\n\n              case 43:\n                _context6.t1 = path;\n\n              case 44:\n                _targetPath = _context6.t1;\n\n                if (!this.fsw.closed) {\n                  _context6.next = 47;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 47:\n                parent = sysPath.dirname(wh.watchPath);\n\n                this.fsw._getWatchedDir(parent).add(wh.watchPath);\n\n                this.fsw._emit(EV_ADD, wh.watchPath, stats);\n\n                _context6.next = 52;\n                return this._handleDir(parent, stats, initialAdd, depth, path, wh, _targetPath);\n\n              case 52:\n                closer = _context6.sent;\n\n                if (!this.fsw.closed) {\n                  _context6.next = 55;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 55:\n                // preserve this symlink's target path\n                if (_targetPath !== undefined) {\n                  this.fsw._symlinkPaths.set(sysPath.resolve(path), _targetPath);\n                }\n\n                _context6.next = 59;\n                break;\n\n              case 58:\n                closer = this._handleFile(wh.watchPath, stats, initialAdd);\n\n              case 59:\n                ready();\n\n                this.fsw._addPathCloser(path, closer);\n\n                return _context6.abrupt(\"return\", false);\n\n              case 64:\n                _context6.prev = 64;\n                _context6.t2 = _context6[\"catch\"](6);\n\n                if (!this.fsw._handleError(_context6.t2)) {\n                  _context6.next = 69;\n                  break;\n                }\n\n                ready();\n                return _context6.abrupt(\"return\", path);\n\n              case 69:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[6, 64]]);\n      }));\n\n      function _addToNodeFs(_x16, _x17, _x18, _x19, _x20) {\n        return _addToNodeFs2.apply(this, arguments);\n      }\n\n      return _addToNodeFs;\n    }()\n  }]);\n\n  return NodeFsHandler;\n}();\n\nmodule.exports = NodeFsHandler;","map":{"version":3,"sources":["C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/chokidar/lib/nodefs-handler.js"],"names":["fs","require","sysPath","promisify","isBinaryPath","isWindows","isLinux","EMPTY_FN","EMPTY_STR","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","EV_CHANGE","EV_ADD","EV_ADD_DIR","EV_ERROR","STR_DATA","STR_END","BRACE_START","STAR","THROTTLE_MODE_WATCH","open","stat","lstat","close","fsrealpath","realpath","statMethods","foreach","val","fn","Set","forEach","addAndConvert","main","prop","item","container","add","clearItem","cont","key","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","path","options","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","resolve","join","watch","error","fullPath","type","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","on","broadcastErr","watcherUnusable","code","fd","listeners","errHandlers","rawEmitters","undefined","Object","freeze","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","prev","currmtime","mtimeMs","NodeFsHandler","fsW","fsw","_boundHandleError","_handleError","opts","directory","dirname","basename","parent","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","file","stats","initialAdd","closed","prevStats","has","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_watchWithNodeFs","_remove","ignoreInitial","_isntIgnored","entry","full","dir","followSymlinks","_incrReadyCount","linkPath","_emitReady","_symlinkPaths","wh","target","depth","throttler","hasGlob","previous","current","stream","_readdirp","fileFilter","filterPath","directoryFilter","filterDir","isSymbolicLink","_handleSymlink","relative","_addToNodeFs","Promise","once","wasThrottled","getChildren","filter","_handleRead","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","statMethod","watchPath","follow","includes","isDirectory","absPath","targetPath","_handleDir","_handleFile","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst sysPath = require('path');\r\nconst { promisify } = require('util');\r\nconst isBinaryPath = require('is-binary-path');\r\nconst {\r\n  isWindows,\r\n  isLinux,\r\n  EMPTY_FN,\r\n  EMPTY_STR,\r\n  KEY_LISTENERS,\r\n  KEY_ERR,\r\n  KEY_RAW,\r\n  HANDLER_KEYS,\r\n  EV_CHANGE,\r\n  EV_ADD,\r\n  EV_ADD_DIR,\r\n  EV_ERROR,\r\n  STR_DATA,\r\n  STR_END,\r\n  BRACE_START,\r\n  STAR\r\n} = require('./constants');\r\n\r\nconst THROTTLE_MODE_WATCH = 'watch';\r\n\r\nconst open = promisify(fs.open);\r\nconst stat = promisify(fs.stat);\r\nconst lstat = promisify(fs.lstat);\r\nconst close = promisify(fs.close);\r\nconst fsrealpath = promisify(fs.realpath);\r\n\r\nconst statMethods = { lstat, stat };\r\n\r\n// TODO: emit errors properly. Example: EMFILE on Macos.\r\nconst foreach = (val, fn) => {\r\n  if (val instanceof Set) {\r\n    val.forEach(fn);\r\n  } else {\r\n    fn(val);\r\n  }\r\n};\r\n\r\nconst addAndConvert = (main, prop, item) => {\r\n  let container = main[prop];\r\n  if (!(container instanceof Set)) {\r\n    main[prop] = container = new Set([container]);\r\n  }\r\n  container.add(item);\r\n};\r\n\r\nconst clearItem = cont => key => {\r\n  const set = cont[key];\r\n  if (set instanceof Set) {\r\n    set.clear();\r\n  } else {\r\n    delete cont[key];\r\n  }\r\n};\r\n\r\nconst delFromSet = (main, prop, item) => {\r\n  const container = main[prop];\r\n  if (container instanceof Set) {\r\n    container.delete(item);\r\n  } else if (container === item) {\r\n    delete main[prop];\r\n  }\r\n};\r\n\r\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\r\n\r\n/**\r\n * @typedef {String} Path\r\n */\r\n\r\n// fs_watch helpers\r\n\r\n// object to hold per-process fs_watch instances\r\n// (may be shared across chokidar FSWatcher instances)\r\n\r\n/**\r\n * @typedef {Object} FsWatchContainer\r\n * @property {Set} listeners\r\n * @property {Set} errHandlers\r\n * @property {Set} rawEmitters\r\n * @property {fs.FSWatcher=} watcher\r\n * @property {Boolean=} watcherUnusable\r\n */\r\n\r\n/**\r\n * @type {Map<String,FsWatchContainer>}\r\n */\r\nconst FsWatchInstances = new Map();\r\n\r\n/**\r\n * Instantiates the fs_watch interface\r\n * @param {String} path to be watched\r\n * @param {Object} options to be passed to fs_watch\r\n * @param {Function} listener main event handler\r\n * @param {Function} errHandler emits info about errors\r\n * @param {Function} emitRaw emits raw event data\r\n * @returns {fs.FSWatcher} new fsevents instance\r\n */\r\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\r\n  const handleEvent = (rawEvent, evPath) => {\r\n    listener(path);\r\n    emitRaw(rawEvent, evPath, {watchedPath: path});\r\n\r\n    // emit based on events occurring for files from a directory's watcher in\r\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\r\n    if (evPath && path !== evPath) {\r\n      fsWatchBroadcast(\r\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\r\n      );\r\n    }\r\n  };\r\n  try {\r\n    return fs.watch(path, options, handleEvent);\r\n  } catch (error) {\r\n    errHandler(error);\r\n  }\r\n}\r\n\r\n/**\r\n * Helper for passing fs_watch event data to a collection of listeners\r\n * @param {Path} fullPath absolute path bound to fs_watch instance\r\n * @param {String} type listener type\r\n * @param {*=} val1 arguments to be passed to listeners\r\n * @param {*=} val2\r\n * @param {*=} val3\r\n */\r\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\r\n  const cont = FsWatchInstances.get(fullPath);\r\n  if (!cont) return;\r\n  foreach(cont[type], (listener) => {\r\n    listener(val1, val2, val3);\r\n  });\r\n};\r\n\r\n/**\r\n * Instantiates the fs_watch interface or binds listeners\r\n * to an existing one covering the same file system entry\r\n * @param {String} path\r\n * @param {String} fullPath absolute path\r\n * @param {Object} options to be passed to fs_watch\r\n * @param {Object} handlers container for event listener functions\r\n */\r\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\r\n  const {listener, errHandler, rawEmitter} = handlers;\r\n  let cont = FsWatchInstances.get(fullPath);\r\n\r\n  /** @type {fs.FSWatcher=} */\r\n  let watcher;\r\n  if (!options.persistent) {\r\n    watcher = createFsWatchInstance(\r\n      path, options, listener, errHandler, rawEmitter\r\n    );\r\n    return watcher.close.bind(watcher);\r\n  }\r\n  if (cont) {\r\n    addAndConvert(cont, KEY_LISTENERS, listener);\r\n    addAndConvert(cont, KEY_ERR, errHandler);\r\n    addAndConvert(cont, KEY_RAW, rawEmitter);\r\n  } else {\r\n    watcher = createFsWatchInstance(\r\n      path,\r\n      options,\r\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\r\n      errHandler, // no need to use broadcast here\r\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\r\n    );\r\n    if (!watcher) return;\r\n    watcher.on(EV_ERROR, async (error) => {\r\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\r\n      cont.watcherUnusable = true; // documented since Node 10.4.1\r\n      // Workaround for https://github.com/joyent/node/issues/4337\r\n      if (isWindows && error.code === 'EPERM') {\r\n        try {\r\n          const fd = await open(path, 'r');\r\n          await close(fd);\r\n          broadcastErr(error);\r\n        } catch (err) {}\r\n      } else {\r\n        broadcastErr(error);\r\n      }\r\n    });\r\n    cont = {\r\n      listeners: listener,\r\n      errHandlers: errHandler,\r\n      rawEmitters: rawEmitter,\r\n      watcher\r\n    };\r\n    FsWatchInstances.set(fullPath, cont);\r\n  }\r\n  // const index = cont.listeners.indexOf(listener);\r\n\r\n  // removes this instance's listeners and closes the underlying fs_watch\r\n  // instance if there are no more listeners left\r\n  return () => {\r\n    delFromSet(cont, KEY_LISTENERS, listener);\r\n    delFromSet(cont, KEY_ERR, errHandler);\r\n    delFromSet(cont, KEY_RAW, rawEmitter);\r\n    if (isEmptySet(cont.listeners)) {\r\n      // Check to protect against issue gh-730.\r\n      // if (cont.watcherUnusable) {\r\n      cont.watcher.close();\r\n      // }\r\n      FsWatchInstances.delete(fullPath);\r\n      HANDLER_KEYS.forEach(clearItem(cont));\r\n      cont.watcher = undefined;\r\n      Object.freeze(cont);\r\n    }\r\n  };\r\n};\r\n\r\n// fs_watchFile helpers\r\n\r\n// object to hold per-process fs_watchFile instances\r\n// (may be shared across chokidar FSWatcher instances)\r\nconst FsWatchFileInstances = new Map();\r\n\r\n/**\r\n * Instantiates the fs_watchFile interface or binds listeners\r\n * to an existing one covering the same file system entry\r\n * @param {String} path to be watched\r\n * @param {String} fullPath absolute path\r\n * @param {Object} options options to be passed to fs_watchFile\r\n * @param {Object} handlers container for event listener functions\r\n * @returns {Function} closer\r\n */\r\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\r\n  const {listener, rawEmitter} = handlers;\r\n  let cont = FsWatchFileInstances.get(fullPath);\r\n\r\n  /* eslint-disable no-unused-vars, prefer-destructuring */\r\n  let listeners = new Set();\r\n  let rawEmitters = new Set();\r\n\r\n  const copts = cont && cont.options;\r\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\r\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\r\n    // This creates some unlikely edge case issues if the user mixes\r\n    // settings in a very weird way, but solving for those cases\r\n    // doesn't seem worthwhile for the added complexity.\r\n    listeners = cont.listeners;\r\n    rawEmitters = cont.rawEmitters;\r\n    fs.unwatchFile(fullPath);\r\n    cont = undefined;\r\n  }\r\n\r\n  /* eslint-enable no-unused-vars, prefer-destructuring */\r\n\r\n  if (cont) {\r\n    addAndConvert(cont, KEY_LISTENERS, listener);\r\n    addAndConvert(cont, KEY_RAW, rawEmitter);\r\n  } else {\r\n    // TODO\r\n    // listeners.add(listener);\r\n    // rawEmitters.add(rawEmitter);\r\n    cont = {\r\n      listeners: listener,\r\n      rawEmitters: rawEmitter,\r\n      options,\r\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\r\n        foreach(cont.rawEmitters, (rawEmitter) => {\r\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\r\n        });\r\n        const currmtime = curr.mtimeMs;\r\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\r\n          foreach(cont.listeners, (listener) => listener(path, curr));\r\n        }\r\n      })\r\n    };\r\n    FsWatchFileInstances.set(fullPath, cont);\r\n  }\r\n  // const index = cont.listeners.indexOf(listener);\r\n\r\n  // Removes this instance's listeners and closes the underlying fs_watchFile\r\n  // instance if there are no more listeners left.\r\n  return () => {\r\n    delFromSet(cont, KEY_LISTENERS, listener);\r\n    delFromSet(cont, KEY_RAW, rawEmitter);\r\n    if (isEmptySet(cont.listeners)) {\r\n      FsWatchFileInstances.delete(fullPath);\r\n      fs.unwatchFile(fullPath);\r\n      cont.options = cont.watcher = undefined;\r\n      Object.freeze(cont);\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * @mixin\r\n */\r\nclass NodeFsHandler {\r\n\r\n/**\r\n * @param {import(\"../index\").FSWatcher} fsW\r\n */\r\nconstructor(fsW) {\r\n  this.fsw = fsW;\r\n  this._boundHandleError = (error) => fsW._handleError(error);\r\n}\r\n\r\n/**\r\n * Watch file for changes with fs_watchFile or fs_watch.\r\n * @param {String} path to file or dir\r\n * @param {Function} listener on fs change\r\n * @returns {Function} closer for the watcher instance\r\n */\r\n_watchWithNodeFs(path, listener) {\r\n  const opts = this.fsw.options;\r\n  const directory = sysPath.dirname(path);\r\n  const basename = sysPath.basename(path);\r\n  const parent = this.fsw._getWatchedDir(directory);\r\n  parent.add(basename);\r\n  const absolutePath = sysPath.resolve(path);\r\n  const options = {persistent: opts.persistent};\r\n  if (!listener) listener = EMPTY_FN;\r\n\r\n  let closer;\r\n  if (opts.usePolling) {\r\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\r\n      opts.binaryInterval : opts.interval;\r\n    closer = setFsWatchFileListener(path, absolutePath, options, {\r\n      listener,\r\n      rawEmitter: this.fsw._emitRaw\r\n    });\r\n  } else {\r\n    closer = setFsWatchListener(path, absolutePath, options, {\r\n      listener,\r\n      errHandler: this._boundHandleError,\r\n      rawEmitter: this.fsw._emitRaw\r\n    });\r\n  }\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Watch a file and emit add event if warranted.\r\n * @param {Path} file Path\r\n * @param {fs.Stats} stats result of fs_stat\r\n * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n * @returns {Function} closer for the watcher instance\r\n */\r\n_handleFile(file, stats, initialAdd) {\r\n  if (this.fsw.closed) {\r\n    return;\r\n  }\r\n  const dirname = sysPath.dirname(file);\r\n  const basename = sysPath.basename(file);\r\n  const parent = this.fsw._getWatchedDir(dirname);\r\n  // stats is always present\r\n  let prevStats = stats;\r\n\r\n  // if the file is already being watched, do nothing\r\n  if (parent.has(basename)) return;\r\n\r\n  const listener = async (path, newStats) => {\r\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\r\n    if (!newStats || newStats.mtimeMs === 0) {\r\n      try {\r\n        const newStats = await stat(file);\r\n        if (this.fsw.closed) return;\r\n        // Check that change event was not fired because of changed only accessTime.\r\n        const at = newStats.atimeMs;\r\n        const mt = newStats.mtimeMs;\r\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\r\n          this.fsw._emit(EV_CHANGE, file, newStats);\r\n        }\r\n        if (isLinux && prevStats.ino !== newStats.ino) {\r\n          this.fsw._closeFile(path)\r\n          prevStats = newStats;\r\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\r\n        } else {\r\n          prevStats = newStats;\r\n        }\r\n      } catch (error) {\r\n        // Fix issues where mtime is null but file is still present\r\n        this.fsw._remove(dirname, basename);\r\n      }\r\n      // add is about to be emitted if file not already tracked in parent\r\n    } else if (parent.has(basename)) {\r\n      // Check that change event was not fired because of changed only accessTime.\r\n      const at = newStats.atimeMs;\r\n      const mt = newStats.mtimeMs;\r\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\r\n        this.fsw._emit(EV_CHANGE, file, newStats);\r\n      }\r\n      prevStats = newStats;\r\n    }\r\n  }\r\n  // kick off the watcher\r\n  const closer = this._watchWithNodeFs(file, listener);\r\n\r\n  // emit an add event if we're supposed to\r\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\r\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\r\n    this.fsw._emit(EV_ADD, file, stats);\r\n  }\r\n\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Handle symlinks encountered while reading a dir.\r\n * @param {Object} entry returned by readdirp\r\n * @param {String} directory path of dir being read\r\n * @param {String} path of this item\r\n * @param {String} item basename of this item\r\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\r\n */\r\nasync _handleSymlink(entry, directory, path, item) {\r\n  if (this.fsw.closed) {\r\n    return;\r\n  }\r\n  const full = entry.fullPath;\r\n  const dir = this.fsw._getWatchedDir(directory);\r\n\r\n  if (!this.fsw.options.followSymlinks) {\r\n    // watch symlink directly (don't follow) and detect changes\r\n    this.fsw._incrReadyCount();\r\n\r\n    let linkPath;\r\n    try {\r\n      linkPath = await fsrealpath(path);\r\n    } catch (e) {\r\n      this.fsw._emitReady();\r\n      return true;\r\n    }\r\n\r\n    if (this.fsw.closed) return;\r\n    if (dir.has(item)) {\r\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\r\n        this.fsw._symlinkPaths.set(full, linkPath);\r\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\r\n      }\r\n    } else {\r\n      dir.add(item);\r\n      this.fsw._symlinkPaths.set(full, linkPath);\r\n      this.fsw._emit(EV_ADD, path, entry.stats);\r\n    }\r\n    this.fsw._emitReady();\r\n    return true;\r\n  }\r\n\r\n  // don't follow the same symlink more than once\r\n  if (this.fsw._symlinkPaths.has(full)) {\r\n    return true;\r\n  }\r\n\r\n  this.fsw._symlinkPaths.set(full, true);\r\n}\r\n\r\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\r\n  // Normalize the directory name on Windows\r\n  directory = sysPath.join(directory, EMPTY_STR);\r\n\r\n  if (!wh.hasGlob) {\r\n    throttler = this.fsw._throttle('readdir', directory, 1000);\r\n    if (!throttler) return;\r\n  }\r\n\r\n  const previous = this.fsw._getWatchedDir(wh.path);\r\n  const current = new Set();\r\n\r\n  let stream = this.fsw._readdirp(directory, {\r\n    fileFilter: entry => wh.filterPath(entry),\r\n    directoryFilter: entry => wh.filterDir(entry),\r\n    depth: 0\r\n  }).on(STR_DATA, async (entry) => {\r\n    if (this.fsw.closed) {\r\n      stream = undefined;\r\n      return;\r\n    }\r\n    const item = entry.path;\r\n    let path = sysPath.join(directory, item);\r\n    current.add(item);\r\n\r\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\r\n      return;\r\n    }\r\n\r\n    if (this.fsw.closed) {\r\n      stream = undefined;\r\n      return;\r\n    }\r\n    // Files that present in current directory snapshot\r\n    // but absent in previous are added to watch list and\r\n    // emit `add` event.\r\n    if (item === target || !target && !previous.has(item)) {\r\n      this.fsw._incrReadyCount();\r\n\r\n      // ensure relativeness of path is preserved in case of watcher reuse\r\n      path = sysPath.join(dir, sysPath.relative(dir, path));\r\n\r\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\r\n    }\r\n  }).on(EV_ERROR, this._boundHandleError);\r\n\r\n  return new Promise(resolve =>\r\n    stream.once(STR_END, () => {\r\n      if (this.fsw.closed) {\r\n        stream = undefined;\r\n        return;\r\n      }\r\n      const wasThrottled = throttler ? throttler.clear() : false;\r\n\r\n      resolve();\r\n\r\n      // Files that absent in current directory snapshot\r\n      // but present in previous emit `remove` event\r\n      // and are removed from @watched[directory].\r\n      previous.getChildren().filter((item) => {\r\n        return item !== directory &&\r\n          !current.has(item) &&\r\n          // in case of intersecting globs;\r\n          // a path may have been filtered out of this readdir, but\r\n          // shouldn't be removed because it matches a different glob\r\n          (!wh.hasGlob || wh.filterPath({\r\n            fullPath: sysPath.resolve(directory, item)\r\n          }));\r\n      }).forEach((item) => {\r\n        this.fsw._remove(directory, item);\r\n      });\r\n\r\n      stream = undefined;\r\n\r\n      // one more time for any missed in case changes came in extremely quickly\r\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\r\n    })\r\n  );\r\n}\r\n\r\n/**\r\n * Read directory to add / remove files from `@watched` list and re-read it on change.\r\n * @param {String} dir fs path\r\n * @param {fs.Stats} stats\r\n * @param {Boolean} initialAdd\r\n * @param {Number} depth relative to user-supplied path\r\n * @param {String} target child path targeted for watch\r\n * @param {Object} wh Common watch helpers for this path\r\n * @param {String} realpath\r\n * @returns {Promise<Function>} closer for the watcher instance.\r\n */\r\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\r\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\r\n  const tracked = parentDir.has(sysPath.basename(dir));\r\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\r\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\r\n  }\r\n\r\n  // ensure dir is tracked (harmless if redundant)\r\n  parentDir.add(sysPath.basename(dir));\r\n  this.fsw._getWatchedDir(dir);\r\n  let throttler;\r\n  let closer;\r\n\r\n  const oDepth = this.fsw.options.depth;\r\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\r\n    if (!target) {\r\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\r\n      if (this.fsw.closed) return;\r\n    }\r\n\r\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\r\n      // if current directory is removed, do nothing\r\n      if (stats && stats.mtimeMs === 0) return;\r\n\r\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\r\n    });\r\n  }\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Handle added file, directory, or glob pattern.\r\n * Delegates call to _handleFile / _handleDir after checks.\r\n * @param {String} path to file or ir\r\n * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n * @param {Object} priorWh depth relative to user-supplied path\r\n * @param {Number} depth Child path actually targeted for watch\r\n * @param {String=} target Child path actually targeted for watch\r\n * @returns {Promise}\r\n */\r\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\r\n  const ready = this.fsw._emitReady;\r\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\r\n    ready();\r\n    return false;\r\n  }\r\n\r\n  const wh = this.fsw._getWatchHelpers(path, depth);\r\n  if (!wh.hasGlob && priorWh) {\r\n    wh.hasGlob = priorWh.hasGlob;\r\n    wh.globFilter = priorWh.globFilter;\r\n    wh.filterPath = entry => priorWh.filterPath(entry);\r\n    wh.filterDir = entry => priorWh.filterDir(entry);\r\n  }\r\n\r\n  // evaluate what is at the path we're being asked to watch\r\n  try {\r\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\r\n    if (this.fsw.closed) return;\r\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\r\n      ready();\r\n      return false;\r\n    }\r\n\r\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\r\n    let closer;\r\n    if (stats.isDirectory()) {\r\n      const absPath = sysPath.resolve(path);\r\n      const targetPath = follow ? await fsrealpath(path) : path;\r\n      if (this.fsw.closed) return;\r\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\r\n      if (this.fsw.closed) return;\r\n      // preserve this symlink's target path\r\n      if (absPath !== targetPath && targetPath !== undefined) {\r\n        this.fsw._symlinkPaths.set(absPath, targetPath);\r\n      }\r\n    } else if (stats.isSymbolicLink()) {\r\n      const targetPath = follow ? await fsrealpath(path) : path;\r\n      if (this.fsw.closed) return;\r\n      const parent = sysPath.dirname(wh.watchPath);\r\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\r\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\r\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\r\n      if (this.fsw.closed) return;\r\n\r\n      // preserve this symlink's target path\r\n      if (targetPath !== undefined) {\r\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\r\n      }\r\n    } else {\r\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\r\n    }\r\n    ready();\r\n\r\n    this.fsw._addPathCloser(path, closer);\r\n    return false;\r\n\r\n  } catch (error) {\r\n    if (this.fsw._handleError(error)) {\r\n      ready();\r\n      return path;\r\n    }\r\n  }\r\n}\r\n\r\n}\r\n\r\nmodule.exports = NodeFsHandler;\r\n"]},"metadata":{},"sourceType":"script"}