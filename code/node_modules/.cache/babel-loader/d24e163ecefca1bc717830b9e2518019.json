{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _typeof = require(\"C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/@babel/runtime/helpers/typeof.js\").default;\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.string.match.js\");\n\nrequire(\"core-js/modules/es.regexp.constructor.js\");\n\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\n\nrequire(\"core-js/modules/es.regexp.sticky.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.regexp.flags.js\");\n\nvar path = require('path');\n\nvar scan = require('./scan');\n\nvar parse = require('./parse');\n\nvar utils = require('./utils');\n\nvar constants = require('./constants');\n\nvar isObject = function isObject(val) {\n  return val && _typeof(val) === 'object' && !Array.isArray(val);\n};\n/**\r\n * Creates a matcher function from one or more glob patterns. The\r\n * returned function takes a string to match as its first argument,\r\n * and returns true if the string is a match. The returned matcher\r\n * function also takes a boolean as the second argument that, when true,\r\n * returns an object with additional information.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch(glob[, options]);\r\n *\r\n * const isMatch = picomatch('*.!(*a)');\r\n * console.log(isMatch('a.a')); //=> false\r\n * console.log(isMatch('a.b')); //=> true\r\n * ```\r\n * @name picomatch\r\n * @param {String|Array} `globs` One or more glob patterns.\r\n * @param {Object=} `options`\r\n * @return {Function=} Returns a matcher function.\r\n * @api public\r\n */\n\n\nvar picomatch = function picomatch(glob, options) {\n  var returnState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (Array.isArray(glob)) {\n    var fns = glob.map(function (input) {\n      return picomatch(input, options, returnState);\n    });\n\n    var arrayMatcher = function arrayMatcher(str) {\n      var _iterator = _createForOfIteratorHelper(fns),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var isMatch = _step.value;\n\n          var _state = isMatch(str);\n\n          if (_state) return _state;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    };\n\n    return arrayMatcher;\n  }\n\n  var isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || typeof glob !== 'string' && !isState) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  var opts = options || {};\n  var posix = utils.isWindows(options);\n  var regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);\n  var state = regex.state;\n  delete regex.state;\n\n  var isIgnored = function isIgnored() {\n    return false;\n  };\n\n  if (opts.ignore) {\n    var ignoreOpts = _objectSpread(_objectSpread({}, options), {}, {\n      ignore: null,\n      onMatch: null,\n      onResult: null\n    });\n\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  var matcher = function matcher(input) {\n    var returnObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var _picomatch$test = picomatch.test(input, regex, options, {\n      glob: glob,\n      posix: posix\n    }),\n        isMatch = _picomatch$test.isMatch,\n        match = _picomatch$test.match,\n        output = _picomatch$test.output;\n\n    var result = {\n      glob: glob,\n      state: state,\n      regex: regex,\n      posix: posix,\n      input: input,\n      output: output,\n      match: match,\n      isMatch: isMatch\n    };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n/**\r\n * Test `input` with the given `regex`. This is used by the main\r\n * `picomatch()` function to test the input string.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.test(input, regex[, options]);\r\n *\r\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\r\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\r\n * ```\r\n * @param {String} `input` String to test.\r\n * @param {RegExp} `regex`\r\n * @return {Object} Returns an object with matching info.\r\n * @api public\r\n */\n\n\npicomatch.test = function (input, regex, options) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      glob = _ref.glob,\n      posix = _ref.posix;\n\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return {\n      isMatch: false,\n      output: ''\n    };\n  }\n\n  var opts = options || {};\n  var format = opts.format || (posix ? utils.toPosixSlashes : null);\n  var match = input === glob;\n  var output = match && format ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return {\n    isMatch: Boolean(match),\n    match: match,\n    output: output\n  };\n};\n/**\r\n * Match the basename of a filepath.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.matchBase(input, glob[, options]);\r\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\r\n * ```\r\n * @param {String} `input` String to test.\r\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\npicomatch.matchBase = function (input, glob, options) {\n  var posix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : utils.isWindows(options);\n  var regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n/**\r\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.isMatch(string, patterns[, options]);\r\n *\r\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\r\n * ```\r\n * @param {String|Array} str The string to test.\r\n * @param {String|Array} patterns One or more glob patterns to use for matching.\r\n * @param {Object} [options] See available [options](#options).\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\n\npicomatch.isMatch = function (str, patterns, options) {\n  return picomatch(patterns, options)(str);\n};\n/**\r\n * Parse a glob pattern to create the source string for a regular\r\n * expression.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * const result = picomatch.parse(pattern[, options]);\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\r\n * @api public\r\n */\n\n\npicomatch.parse = function (pattern, options) {\n  if (Array.isArray(pattern)) return pattern.map(function (p) {\n    return picomatch.parse(p, options);\n  });\n  return parse(pattern, _objectSpread(_objectSpread({}, options), {}, {\n    fastpaths: false\n  }));\n};\n/**\r\n * Scan a glob pattern to separate the pattern into segments.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.scan(input[, options]);\r\n *\r\n * const result = picomatch.scan('!./foo/*.js');\r\n * console.log(result);\r\n * { prefix: '!./',\r\n *   input: '!./foo/*.js',\r\n *   start: 3,\r\n *   base: 'foo',\r\n *   glob: '*.js',\r\n *   isBrace: false,\r\n *   isBracket: false,\r\n *   isGlob: true,\r\n *   isExtglob: false,\r\n *   isGlobstar: false,\r\n *   negated: true }\r\n * ```\r\n * @param {String} `input` Glob pattern to scan.\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with\r\n * @api public\r\n */\n\n\npicomatch.scan = function (input, options) {\n  return scan(input, options);\n};\n/**\r\n * Compile a regular expression from the `state` object returned by the\r\n * [parse()](#parse) method.\r\n *\r\n * @param {Object} `state`\r\n * @param {Object} `options`\r\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\r\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\r\n * @return {RegExp}\r\n * @api public\r\n */\n\n\npicomatch.compileRe = function (state, options) {\n  var returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  var opts = options || {};\n  var prepend = opts.contains ? '' : '^';\n  var append = opts.contains ? '' : '$';\n  var source = \"\".concat(prepend, \"(?:\").concat(state.output, \")\").concat(append);\n\n  if (state && state.negated === true) {\n    source = \"^(?!\".concat(source, \").*$\");\n  }\n\n  var regex = picomatch.toRegex(source, options);\n\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n/**\r\n * Create a regular expression from a parsed glob pattern.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * const state = picomatch.parse('*.js');\r\n * // picomatch.compileRe(state[, options]);\r\n *\r\n * console.log(picomatch.compileRe(state));\r\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n * ```\r\n * @param {String} `state` The object returned from the `.parse` method.\r\n * @param {Object} `options`\r\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\r\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\n\n\npicomatch.makeRe = function (input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  var parsed = {\n    negated: false,\n    fastpaths: true\n  };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n/**\r\n * Create a regular expression from the given regex source string.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.toRegex(source[, options]);\r\n *\r\n * const { output } = picomatch.parse('*.js');\r\n * console.log(picomatch.toRegex(output));\r\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n * ```\r\n * @param {String} `source` Regular expression source string.\r\n * @param {Object} `options`\r\n * @return {RegExp}\r\n * @api public\r\n */\n\n\npicomatch.toRegex = function (source, options) {\n  try {\n    var opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n/**\r\n * Picomatch constants.\r\n * @return {Object}\r\n */\n\n\npicomatch.constants = constants;\n/**\r\n * Expose \"picomatch\"\r\n */\n\nmodule.exports = picomatch;","map":{"version":3,"sources":["C:/Users/wingd/OneDrive/Documentos/GitHub/desafio-coordene/code/node_modules/picomatch/lib/picomatch.js"],"names":["path","require","scan","parse","utils","constants","isObject","val","Array","isArray","picomatch","glob","options","returnState","fns","map","input","arrayMatcher","str","isMatch","state","isState","tokens","TypeError","opts","posix","isWindows","regex","compileRe","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","test","match","output","result","onIgnore","format","toPosixSlashes","capture","matchBase","basename","exec","Boolean","RegExp","patterns","pattern","p","fastpaths","returnOutput","prepend","contains","append","source","negated","toRegex","parsed","flags","nocase","err","debug","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst path = require('path');\r\nconst scan = require('./scan');\r\nconst parse = require('./parse');\r\nconst utils = require('./utils');\r\nconst constants = require('./constants');\r\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\r\n\r\n/**\r\n * Creates a matcher function from one or more glob patterns. The\r\n * returned function takes a string to match as its first argument,\r\n * and returns true if the string is a match. The returned matcher\r\n * function also takes a boolean as the second argument that, when true,\r\n * returns an object with additional information.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch(glob[, options]);\r\n *\r\n * const isMatch = picomatch('*.!(*a)');\r\n * console.log(isMatch('a.a')); //=> false\r\n * console.log(isMatch('a.b')); //=> true\r\n * ```\r\n * @name picomatch\r\n * @param {String|Array} `globs` One or more glob patterns.\r\n * @param {Object=} `options`\r\n * @return {Function=} Returns a matcher function.\r\n * @api public\r\n */\r\n\r\nconst picomatch = (glob, options, returnState = false) => {\r\n  if (Array.isArray(glob)) {\r\n    const fns = glob.map(input => picomatch(input, options, returnState));\r\n    const arrayMatcher = str => {\r\n      for (const isMatch of fns) {\r\n        const state = isMatch(str);\r\n        if (state) return state;\r\n      }\r\n      return false;\r\n    };\r\n    return arrayMatcher;\r\n  }\r\n\r\n  const isState = isObject(glob) && glob.tokens && glob.input;\r\n\r\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\r\n    throw new TypeError('Expected pattern to be a non-empty string');\r\n  }\r\n\r\n  const opts = options || {};\r\n  const posix = utils.isWindows(options);\r\n  const regex = isState\r\n    ? picomatch.compileRe(glob, options)\r\n    : picomatch.makeRe(glob, options, false, true);\r\n\r\n  const state = regex.state;\r\n  delete regex.state;\r\n\r\n  let isIgnored = () => false;\r\n  if (opts.ignore) {\r\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\r\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\r\n  }\r\n\r\n  const matcher = (input, returnObject = false) => {\r\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\r\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\r\n\r\n    if (typeof opts.onResult === 'function') {\r\n      opts.onResult(result);\r\n    }\r\n\r\n    if (isMatch === false) {\r\n      result.isMatch = false;\r\n      return returnObject ? result : false;\r\n    }\r\n\r\n    if (isIgnored(input)) {\r\n      if (typeof opts.onIgnore === 'function') {\r\n        opts.onIgnore(result);\r\n      }\r\n      result.isMatch = false;\r\n      return returnObject ? result : false;\r\n    }\r\n\r\n    if (typeof opts.onMatch === 'function') {\r\n      opts.onMatch(result);\r\n    }\r\n    return returnObject ? result : true;\r\n  };\r\n\r\n  if (returnState) {\r\n    matcher.state = state;\r\n  }\r\n\r\n  return matcher;\r\n};\r\n\r\n/**\r\n * Test `input` with the given `regex`. This is used by the main\r\n * `picomatch()` function to test the input string.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.test(input, regex[, options]);\r\n *\r\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\r\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\r\n * ```\r\n * @param {String} `input` String to test.\r\n * @param {RegExp} `regex`\r\n * @return {Object} Returns an object with matching info.\r\n * @api public\r\n */\r\n\r\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\r\n  if (typeof input !== 'string') {\r\n    throw new TypeError('Expected input to be a string');\r\n  }\r\n\r\n  if (input === '') {\r\n    return { isMatch: false, output: '' };\r\n  }\r\n\r\n  const opts = options || {};\r\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\r\n  let match = input === glob;\r\n  let output = (match && format) ? format(input) : input;\r\n\r\n  if (match === false) {\r\n    output = format ? format(input) : input;\r\n    match = output === glob;\r\n  }\r\n\r\n  if (match === false || opts.capture === true) {\r\n    if (opts.matchBase === true || opts.basename === true) {\r\n      match = picomatch.matchBase(input, regex, options, posix);\r\n    } else {\r\n      match = regex.exec(output);\r\n    }\r\n  }\r\n\r\n  return { isMatch: Boolean(match), match, output };\r\n};\r\n\r\n/**\r\n * Match the basename of a filepath.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.matchBase(input, glob[, options]);\r\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\r\n * ```\r\n * @param {String} `input` String to test.\r\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\r\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\r\n  return regex.test(path.basename(input));\r\n};\r\n\r\n/**\r\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.isMatch(string, patterns[, options]);\r\n *\r\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\r\n * ```\r\n * @param {String|Array} str The string to test.\r\n * @param {String|Array} patterns One or more glob patterns to use for matching.\r\n * @param {Object} [options] See available [options](#options).\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\r\n\r\n/**\r\n * Parse a glob pattern to create the source string for a regular\r\n * expression.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * const result = picomatch.parse(pattern[, options]);\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\r\n * @api public\r\n */\r\n\r\npicomatch.parse = (pattern, options) => {\r\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\r\n  return parse(pattern, { ...options, fastpaths: false });\r\n};\r\n\r\n/**\r\n * Scan a glob pattern to separate the pattern into segments.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.scan(input[, options]);\r\n *\r\n * const result = picomatch.scan('!./foo/*.js');\r\n * console.log(result);\r\n * { prefix: '!./',\r\n *   input: '!./foo/*.js',\r\n *   start: 3,\r\n *   base: 'foo',\r\n *   glob: '*.js',\r\n *   isBrace: false,\r\n *   isBracket: false,\r\n *   isGlob: true,\r\n *   isExtglob: false,\r\n *   isGlobstar: false,\r\n *   negated: true }\r\n * ```\r\n * @param {String} `input` Glob pattern to scan.\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with\r\n * @api public\r\n */\r\n\r\npicomatch.scan = (input, options) => scan(input, options);\r\n\r\n/**\r\n * Compile a regular expression from the `state` object returned by the\r\n * [parse()](#parse) method.\r\n *\r\n * @param {Object} `state`\r\n * @param {Object} `options`\r\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\r\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\r\n * @return {RegExp}\r\n * @api public\r\n */\r\n\r\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\r\n  if (returnOutput === true) {\r\n    return state.output;\r\n  }\r\n\r\n  const opts = options || {};\r\n  const prepend = opts.contains ? '' : '^';\r\n  const append = opts.contains ? '' : '$';\r\n\r\n  let source = `${prepend}(?:${state.output})${append}`;\r\n  if (state && state.negated === true) {\r\n    source = `^(?!${source}).*$`;\r\n  }\r\n\r\n  const regex = picomatch.toRegex(source, options);\r\n  if (returnState === true) {\r\n    regex.state = state;\r\n  }\r\n\r\n  return regex;\r\n};\r\n\r\n/**\r\n * Create a regular expression from a parsed glob pattern.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * const state = picomatch.parse('*.js');\r\n * // picomatch.compileRe(state[, options]);\r\n *\r\n * console.log(picomatch.compileRe(state));\r\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n * ```\r\n * @param {String} `state` The object returned from the `.parse` method.\r\n * @param {Object} `options`\r\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\r\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\r\n\r\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\r\n  if (!input || typeof input !== 'string') {\r\n    throw new TypeError('Expected a non-empty string');\r\n  }\r\n\r\n  let parsed = { negated: false, fastpaths: true };\r\n\r\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\r\n    parsed.output = parse.fastpaths(input, options);\r\n  }\r\n\r\n  if (!parsed.output) {\r\n    parsed = parse(input, options);\r\n  }\r\n\r\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\r\n};\r\n\r\n/**\r\n * Create a regular expression from the given regex source string.\r\n *\r\n * ```js\r\n * const picomatch = require('picomatch');\r\n * // picomatch.toRegex(source[, options]);\r\n *\r\n * const { output } = picomatch.parse('*.js');\r\n * console.log(picomatch.toRegex(output));\r\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n * ```\r\n * @param {String} `source` Regular expression source string.\r\n * @param {Object} `options`\r\n * @return {RegExp}\r\n * @api public\r\n */\r\n\r\npicomatch.toRegex = (source, options) => {\r\n  try {\r\n    const opts = options || {};\r\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\r\n  } catch (err) {\r\n    if (options && options.debug === true) throw err;\r\n    return /$^/;\r\n  }\r\n};\r\n\r\n/**\r\n * Picomatch constants.\r\n * @return {Object}\r\n */\r\n\r\npicomatch.constants = constants;\r\n\r\n/**\r\n * Expose \"picomatch\"\r\n */\r\n\r\nmodule.exports = picomatch;\r\n"]},"metadata":{},"sourceType":"script"}